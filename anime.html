<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AnimeList - Anime</title>

  <style>
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #06b6d4;
      --accent2: #f97316;
      --muted: #9ca3af;
      --glass: rgba(255,255,255,0.05);
      --radius: 12px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Inter', sans-serif;
      background: #0f1724;
      color: #e6eef6;
      line-height: 1.6;
      overflow-x: hidden;
    }
    a { text-decoration: none; color: inherit; }

    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(11,18,32,0.95);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 40px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.4);
    }
    header h1 { font-size: 28px; font-weight: 700; letter-spacing: 1px; }
    header nav a {
      margin-left: 20px;
      font-weight: 500;
      color: var(--muted);
      transition: color 0.2s;
    }
    header nav a:hover { color: var(--accent); }

	:focus-visible {
	  outline: 2px solid rgba(6,182,212,0.8);
	  outline-offset: 2px;
	}

    #particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .container { 
      max-width: 1000px; 
      margin: 60px auto; 
      padding: 0 20px; 
      position: relative;
      z-index: 1;
    }

    .anime-details {
      display: flex;
      gap: 40px;
      background: var(--card);
      padding: 30px;
      border-radius: var(--radius);
      box-shadow: 0 8px 24px rgba(0,0,0,0.6);
      flex-wrap: wrap;
      transition: transform 0.3s;
	  border: 1px solid rgba(255,255,255,0.06);
    }
    .anime-details:hover { 
	  transform: scale(1.01);
	  box-shadow:
        0 10px 30px rgba(0,0,0,0.7),
        0 0 20px rgba(6,182,212,0.25);
	}

    .anime-details img {
      width: 320px;
      height: 450px;
      object-fit: cover;
      border-radius: var(--radius);
      flex-shrink: 0;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      transition: transform 0.4s ease, box-shadow 0.4s ease;
    }
	.anime-details:hover img {
	  transform: scale(1.04);
	  box-shadow:
		0 12px 30px rgba(0,0,0,0.7),
		0 0 18px rgba(6,182,212,0.35);
	}
    .anime-info { flex: 1; display: flex; flex-direction: column; gap: 12px; }
    .anime-info h2 { 
	  font-size: 32px; 
	  font-weight: 700; 
	  color: var(--accent); 
	  text-shadow: 0 0 12px rgba(6,182,212,0.35);
	}
    .anime-info .genres { display: flex; gap: 8px; flex-wrap: wrap; }
    .anime-info .genres a {
      display: inline-block;
      background: rgba(6,182,212,0.15);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--accent);
      transition: all 0.3s;
	  border: 1px solid rgba(6,182,212,0.35);
    }
    .anime-info .genres a:hover { 
      transform: scale(1.1);
      background: rgba(6,182,212,0.25);
	  box-shadow: 0 0 10px rgba(6,182,212,0.4);
    }
    .anime-info .rating {
      font-weight: 700;
      background: rgba(6,182,212,0.15);
      padding: 6px 10px;
      border-radius: 8px;
      width: fit-content;
      color: var(--accent);
    }

	.status-group {
	  display: flex;
	  flex-wrap: wrap;
	  gap: 10px;
	  margin-top: 6px;
	}

	.status-label {
	  font-size: 13px;
	  color: var(--muted);
	  margin-top: 6px;
	}

	.status-btn {
	  padding: 8px 14px;
	  border-radius: 999px;
	  border: 1px solid rgba(255,255,255,0.15);
	  background: rgba(255,255,255,0.06);
	  color: #e6eef6;
	  font-size: 13px;
	  font-weight: 700;
	  cursor: pointer;
	  transition: all 0.2s ease;
	}

	.status-btn:hover {
	  transform: translateY(-1px);
	  border-color: rgba(6,182,212,0.5);
	  box-shadow: 0 8px 18px rgba(6,182,212,0.2);
	}

	.status-btn.is-active {
	  background: linear-gradient(135deg, #06b6d4, #3b82f6);
	  color: #052226;
	  border-color: transparent;
	  box-shadow: 0 10px 24px rgba(6,182,212,0.4);
	}

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: var(--radius);
      background: linear-gradient(135deg, var(--accent), #0fc1e5);
      color: #052226;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.25s ease;
      margin-top: 10px;
      width: fit-content;
      box-shadow: 0 4px 15px rgba(6,182,212,0.4);
	  position: relative;
	  overflow: hidden;
    }
    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(6,182,212,0.7);
    }
	.btn:active {
	  transform: translateY(0) scale(0.97);
	}
    .anime-summary {
      margin-top: 30px;
      font-size: 16px;
      line-height: 1.8;
      background: var(--glass);
      padding: 20px;
      border-radius: var(--radius);
      backdrop-filter: blur(4px);
	  border: 1px solid rgba(255,255,255,0.06);
	  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
    }
	.anime-summary::before {
	  content: "üìñ Synopsis";
	  display: block;
	  font-weight: 700;
	  margin-bottom: 10px;
	  color: var(--accent);
	}
    footer {
      text-align: center;
      margin: 60px 0 20px;
      color: #9ca3af;
      font-size: 14px;
    }

    @media (max-width: 720px){
	  header {
		flex-direction: column;
		gap: 12px;
		padding: 16px 20px;
	  }
      .anime-details {
        flex-direction: column;
        align-items: center;
      }
      .anime-details img { width: 80%; height: auto; }
      .anime-info h2, .anime-info .btn { text-align: center; }
      .anime-info .btn { margin: 0 auto; display: block; }
      .anime-info .genres { justify-content: center; }
    }
	/* ‚≠ê Select Noter */
	#rateSelect {
	  appearance: none;
	  -webkit-appearance: none;
	  -moz-appearance: none;

	  background: linear-gradient(
		135deg,
		rgba(6, 182, 212, 0.18),
		rgba(15, 193, 229, 0.25)
	  );
	  border: 1px solid rgba(6, 182, 212, 0.4);
	  color: #e6eef6;

	  padding: 10px 42px 10px 14px;
	  border-radius: 12px;
	  font-size: 15px;
	  font-weight: 600;
	  cursor: pointer;

	  box-shadow: 0 6px 20px rgba(6, 182, 212, 0.25);
	  transition: all 0.25s ease;
	  margin-top: 12px;
	  width: fit-content;
	}
	
	/* üîΩ Fl√®che custom */
	#rateSelect {
	  background-image:
		linear-gradient(45deg, transparent 50%, #06b6d4 50%),
		linear-gradient(135deg, #06b6d4 50%, transparent 50%);
	  background-position:
		calc(100% - 20px) 50%,
		calc(100% - 14px) 50%;
	  background-size: 6px 6px;
	  background-repeat: no-repeat;
	}

	/* üñ± Hover */
	#rateSelect:hover {
	  transform: translateY(-2px);
	  box-shadow: 0 10px 28px rgba(6, 182, 212, 0.45);
	  border-color: #06b6d4;
	}

	/* üéØ Focus */
	#rateSelect:focus {
	  outline: none;
	  box-shadow:
		0 0 0 2px rgba(6, 182, 212, 0.4),
		0 12px 30px rgba(6, 182, 212, 0.6);
	}
	#rateSelect:focus-visible {
	  outline: 2px solid #06b6d4;
	  outline-offset: 2px;
	}
	/* üìã Options */
	#rateSelect option {
	  background: #0b1220;
	  color: #e6eef6;
	  font-weight: 500;
	}
	#favBtn.favorited {
	  background: linear-gradient(135deg, #facc15, #f97316);
	  color: #3a2000;
	  box-shadow: 0 12px 30px rgba(250,204,21,0.6);
	}
	/* Petit bounce */
	#favBtn.pop {
	  animation: favPop 0.35s ease;
	}

	@keyframes favPop {
	  0%   { transform: scale(0.9); }
	  60%  { transform: scale(1.15); }
	  100% { transform: scale(1); }
	}

	#favBtn.favorited::after {
	  opacity: 1;
	  transform: translateY(-50%) scale(1);
	}
	#toast {
	  position: fixed;
	  bottom: 30px;
	  left: 50%;
	  transform: translateX(-50%) translateY(20px);
	  background: linear-gradient(135deg, #22c55e, #16a34a);
	  color: #022c22;
	  padding: 14px 24px;
	  border-radius: 14px;
	  font-weight: 700;
	  font-size: 14px;
	  box-shadow: 0 10px 30px rgba(34,197,94,0.45);
	  opacity: 0;
	  pointer-events: none;
	  transition: all 0.35s ease;
	  z-index: 9999;
	}

	#toast.show {
	  opacity: 1;
	  transform: translateX(-50%) translateY(0);
	}

	#toast.remove {
	  background: linear-gradient(135deg, #0ea5e9, #0284c7);
	  color: #042a3f;
	  box-shadow: 0 10px 30px rgba(14,165,233,0.45);
	}
	/* C≈ìur qui poppe */
	#favBtn::before {
	  content: "‚ù§Ô∏è";
	  position: absolute;
	  left: 50%;
	  top: 50%;
	  transform: translate(-50%, -50%) scale(0);
	  font-size: 1.8em;
	  opacity: 0;
	  pointer-events: none;
	  text-shadow: 0 0 5px #fff, 0 0 10px #f00, 0 0 15px #f00;
	}

	#favBtn.liked::before {
	  animation: heartPop 0.6s forwards;
	}

	@keyframes heartPop {
	  0%   { transform: translate(-50%, -50%) scale(0); opacity: 0; }
	  30%  { transform: translate(-50%, -50%) scale(1.4); opacity: 1; }
	  60%  { transform: translate(-50%, -50%) scale(1); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
	}

	/* Particules container */
	#favParticles {
	  position: absolute;
	  pointer-events: none;
	  left: 0; top: 0;
	  width: 100%; height: 100%;
	  overflow: visible;
	}
	#favBtn.removed::before {
	  content: "üíî"; /* ou "‚ù§Ô∏è" si tu veux juste fade-out */
	  position: absolute;
	  left: 50%;
	  top: 50%;
	  transform: translate(-50%, -50%) scale(1);
	  font-size: 1.8em;
	  opacity: 1;
	  pointer-events: none;
	  color: #f00;
	  animation: heartFade 0.5s forwards;
	}

	@keyframes heartFade {
	  0%   { transform: translate(-50%, -50%) scale(1); opacity: 1; }
	  100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
	}
	/* Conteneur boutons header */
	.header-actions {
	  display: flex;
	  gap: 12px;
	  align-items: center;
	}

	/* Boutons favoris et profil */
	.header-actions button, .header-actions a {
	  display: inline-flex;
	  align-items: center;
	  justify-content: center;
	  padding: 8px 16px;
	  font-weight: 700;
	  font-size: 14px;
	  border-radius: var(--radius);
	  border: 1px solid rgba(6,182,212,0.6);
	  cursor: pointer;
	  transition: all 0.3s ease;
	  text-decoration: none;
	  color: #e6eef6;
	  background: linear-gradient(135deg, rgba(6,182,212,0.05), rgba(15,193,229,0.1));
	  box-shadow: 0 0 6px rgba(6,182,212,0.5), 0 4px 12px rgba(6,182,212,0.3);
	  position: relative;
	  overflow: hidden;
	}

	/* Hover */
	.header-actions button:hover, .header-actions a:hover {
	  background: linear-gradient(135deg, var(--accent), var(--accent2));
	  color: #052226;
	  transform: translateY(-2px) scale(1.05);
	  box-shadow:
	    0 0 8px var(--accent),
		0 0 12px var(--accent2),
		0 4px 20px rgba(6,182,212,0.6),
		0 6px 30px rgba(6,182,212,0.3);
	}

	/* Ic√¥nes dans les boutons */
	.header-actions button i, .header-actions a i {
	  margin-right: 6px;
	  font-size: 16px;
	}

	/* Favoris actif */
	.header-actions .favorited {
	  background: linear-gradient(135deg, #facc15, #f97316);
	  color: #3a2000;
	  box-shadow:
	    0 0 10px #facc15,
		0 0 15px #f97316,
		0 6px 24px rgba(250,204,21,0.5);
	}

	/* Petit pop animation */
	.header-actions button.pop {
	  animation: favPop 0.35s ease;
	}
	@keyframes favPop {
	  0%   { transform: scale(0.9); }
	  60%  { transform: scale(1.15); }
	  100% { transform: scale(1); }
	}
	/* Glow anim√© pulse */
	@keyframes neonPulse {
	  0%, 100% { box-shadow: 0 0 6px var(--accent), 0 0 12px var(--accent2); }
	  50% { box-shadow: 0 0 10px var(--accent), 0 0 20px var(--accent2); }
	}

	/* Animation continue */
	.header-actions button,
	.header-actions a {
	  box-shadow:
		0 0 6px rgba(6,182,212,0.4),
		0 4px 10px rgba(6,182,212,0.25);
	}
	/* üîÑ Loader Anime */
	.anime-loader {
	  position: fixed;
	  top: 50%;
	  left: 50%;
	  transform: translate(-50%, -50%);
	  text-align: center;
	  z-index: 999;
	}

	.spinner {
	  width: 60px;
	  height: 60px;
	  border: 5px solid rgba(6,182,212,0.2);
	  border-top: 5px solid #06b6d4;
	  border-radius: 50%;
	  animation: spin 1s linear infinite, pulseGlow 1.5s ease-in-out infinite;
	  margin: 0 auto 16px;
	}
	@keyframes pulseGlow {
	  0%, 100% { box-shadow: 0 0 10px rgba(6,182,212,0.3); }
	  50% { box-shadow: 0 0 25px rgba(6,182,212,0.6); }
	}
	@keyframes spin {
	  to { transform: rotate(360deg); }
	}

	#animeLoadingText {
	  font-size: 16px;
	  color: #9ca3af;
	  font-style: italic;
	}
	@media (max-width: 600px) {
	  .anime-info h2 {
		font-size: 24px;
		text-align: center;
	  }
	  .anime-summary {
		font-size: 15px;
	  }
	  .btn, #rateSelect {
		margin-left: auto;
		margin-right: auto;
	  }
	  .anime-info.rating {
	    margin-left: auto;
		margin-right: auto;
	  }
	  .header-actions {
		width: 100%;
		justify-content: center;
		flex-wrap: wrap;
	  }
	}
	/* üé¨ Bloc saisons */
	.anime-seasons {
	  margin-top: 2px;
	  padding: 18px;
	  border-radius: var(--radius);
	  background: rgba(255,255,255,0.04);
	  border: 1px solid rgba(255,255,255,0.06);
	  backdrop-filter: blur(6px);
	  box-shadow:
		inset 0 0 0 1px rgba(255,255,255,0.02),
		0 6px 18px rgba(0,0,0,0.5);
	}

	/* Titre */
	.anime-seasons h3 {
	  font-size: 18px;
	  font-weight: 700;
	  margin-bottom: 14px;
	  color: var(--accent);
	  display: flex;
	  align-items: center;
	  gap: 8px;
	  text-shadow: 0 0 10px rgba(6,182,212,0.35);
	}

	.anime-seasons h3::before {
	  content: "üì∫";
	}

	/* Liste */
	.seasons-list {
	  display: flex;
	  flex-direction: column;
	  gap: 12px;
	}

	/* Carte saison */
	.season-item {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  padding: 14px 16px;
	  border-radius: 12px;
	  background: linear-gradient(
		135deg,
		rgba(6,182,212,0.08),
		rgba(15,193,229,0.12)
	  );
	  border: 1px solid rgba(6,182,212,0.25);
	  cursor: pointer;
	  transition: all 0.3s ease;
	  position: relative;
	  overflow: hidden;
	}

	/* Glow anim√© au hover */
	.season-item::after {
	  content: "";
	  position: absolute;
	  inset: 0;
	  background: radial-gradient(
		circle at left,
		rgba(6,182,212,0.35),
		transparent 60%
	  );
	  opacity: 0;
	  transition: opacity 0.3s ease;
	}

	.season-item:hover::after {
	  opacity: 1;
	}

	.season-item:hover {
	  transform: translateY(-2px) scale(1.02);
	  box-shadow:
		0 10px 25px rgba(0,0,0,0.6),
		0 0 20px rgba(6,182,212,0.35);
	}

	/* Texte saison */
	.season-title {
	  font-weight: 700;
	  font-size: 15px;
	  color: #e6eef6;
	}

	/* Episodes */
	.season-episodes {
	  font-size: 13px;
	  color: var(--muted);
	  background: rgba(0,0,0,0.25);
	  padding: 4px 10px;
	  border-radius: 999px;
	  border: 1px solid rgba(255,255,255,0.08);
	}

	/* Mobile */
	@media (max-width: 600px) {
	  .anime-seasons {
		padding: 14px;
	  }

	  .season-item {
		flex-direction: column;
		align-items: flex-start;
		gap: 6px;
	  }

	  .season-episodes {
		align-self: flex-end;
	  }
	}
	.season-item.empty {
	  opacity: 0.6;
	  font-style: italic;
	  justify-content: center;
	}
	.badge-upcoming {
	  margin-left: 10px;
	  padding: 3px 8px;
	  font-size: 11px;
	  font-weight: 700;
	  letter-spacing: 0.5px;
	  color: #111;
	  background: linear-gradient(135deg, #ffd86b, #ffb347);
	  border-radius: 12px;
	  text-transform: uppercase;
	  box-shadow: 0 0 10px rgba(255, 200, 80, 0.6);
	  animation: pulseUpcoming 1.8s infinite;
	}

	@keyframes pulseUpcoming {
	  0% {
		box-shadow: 0 0 6px rgba(255, 200, 80, 0.4);
	  }
	  50% {
		box-shadow: 0 0 14px rgba(255, 200, 80, 0.9);
	  }
	  100% {
		box-shadow: 0 0 6px rgba(255, 200, 80, 0.4);
	  }
	}
	.timeline-toggle {
	  margin: 10px 0 16px;
	  padding: 8px 14px;
	  border-radius: 999px;
	  border: 1px solid rgba(255,255,255,0.25);
	  background: rgba(255,255,255,0.08);
	  color: #e6eef6;
	  font-size: 13px;
	  font-weight: 700;
	  cursor: pointer;
	  backdrop-filter: blur(10px);
	  transition: all 0.25s ease;
	}

	.timeline-toggle:hover {
	  background: rgba(6,182,212,0.25);
	  border-color: #06b6d4;
	  transform: translateY(-1px);
	}

	.timeline-toggle.active {
	  background: linear-gradient(135deg, #06b6d4, #3b82f6);
	  color: #052226;
	  border: none;
	}
	.badge-non-canon {
	  margin-left: 8px;
	  padding: 2px 6px;
	  font-size: 10px;
	  font-weight: 800;
	  border-radius: 6px;
	  background: rgba(239,68,68,0.15);
	  color: #f87171;
	  border: 1px solid rgba(239,68,68,0.4);
	  text-transform: uppercase;
	}
	#timelineList {
	  display: flex;
	  flex-direction: column;
	  gap: 10px; /* espace entre chaque case */
	}
	.season-item.movie {
	  border-left: 3px solid #f59e0b;
	}
	/* üß© SPECIAL */
	.season-item.special::before {
	  background: #facc15; /* jaune styl√© */
	}

	.season-item.special .season-episodes {
	  font-weight: 700;
	  font-size: 12px;
	  letter-spacing: 0.6px;
	  text-transform: uppercase;
	  color: #facc15;
	}
  </style>
</head>
<body>

  <div id="particles"></div>

  <header>
    <h1 id="homeLogo" style="cursor:pointer;">AnimeHub</h1>
    <div class="header-actions">
      <button id="goFavs" class="icon-btn">Favoris</button>
      <button id="goProfile" class="icon-btn">Profil</button>
    </div>
  </header>

  <!-- üîÑ LOADER (visible au chargement) -->
  <div id="animeLoader" class="anime-loader">
    <div class="spinner"></div>
    <p id="animeLoadingText"></p>
  </div>

  <!-- üé¨ CONTENU ANIME (cach√© au d√©but) -->
  <div id="animeContent" style="display:none;">
    <div class="container">
      <div class="anime-details">
        <img id="animeImg" src="" alt="Anime Image">

        <div class="anime-info">
          <h2 id="animeTitle"></h2>

          <div class="genres" id="animeGenres">
            <!-- Badges genres cliquables -->
          </div>
		  <div class="anime-seasons" id="animeSeasons">
			<h3 class="section-title">Timeline</h3>
			<button id="toggleCanonBtn" class="timeline-toggle">
			  Afficher le non-canon
			</button>
			<div id="timelineList"></div>
		  </div>
          <div class="rating" id="animeRating"></div>
		  <div class="status-label">Statut de visionnage</div>
		  <div class="status-group" id="watchStatus">
			<button class="status-btn" data-status="watching">En cours</button>
			<button class="status-btn" data-status="completed">Termin√©</button>
			<button class="status-btn" data-status="planned">√Ä voir</button>
		  </div>

          <button class="btn" id="favBtn">Ajouter aux favoris</button>

          <select class="rateSelect" id="rateSelect">
            <option value="">Noter</option>
          </select>
        </div>
      </div>

      <p class="anime-summary" id="animeSummary"></p>
    </div>
  </div>

  <div id="toast"></div>

  <footer>
    ¬© 2026 AnimeHub
  </footer>
  <script>

    const canvas = document.createElement('canvas');
    document.getElementById('particles').appendChild(canvas);
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles = [];
    const particleCount = 80;

    for(let i=0;i<particleCount;i++){
      particles.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r: Math.random()*2+1,
        dx: (Math.random()-0.5)*0.5,
        dy: (Math.random()-0.5)*0.5
      });
    }

    function animateParticles(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      particles.forEach(p=>{
        p.x += p.dx;
        p.y += p.dy;
        if(p.x<0 || p.x>canvas.width) p.dx*=-1;
        if(p.y<0 || p.y>canvas.height) p.dy*=-1;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fillStyle = 'rgba(6,182,212,0.4)';
        ctx.fill();
      });
      requestAnimationFrame(animateParticles);
    }
    animateParticles();
    window.addEventListener('resize', ()=>{canvas.width=window.innerWidth; canvas.height=window.innerHeight;});

    const animeImg = document.getElementById('animeImg');
    window.addEventListener('scroll', ()=>{
      const offset = window.scrollY;
      animeImg.style.transform = `translateY(${offset*0.1}px)`;
    });
	document.getElementById("goFavs")?.addEventListener("click", () => {
	  // Redirection vers la page d'accueil avec filtre favoris
	  window.location.href = "index.html?fav=1";
	});

	document.getElementById("goProfile")?.addEventListener("click", () => {
	  window.location.href = "profile.html";
	});
	document.getElementById("homeLogo").addEventListener("click", () => {
	  window.location.href = "animelist.html";
	});
  </script>
  <script type="module">
	  /*****************************************************
	 * 1Ô∏è‚É£ IMPORTS FIREBASE
	 *****************************************************/
	import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
	import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
	import {
	  getFirestore, doc, getDoc, setDoc, updateDoc,
	  arrayUnion, arrayRemove, increment, deleteField,
	  collection, addDoc, serverTimestamp
	} from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

	/*****************************************************
	 * 2Ô∏è‚É£ FIREBASE INIT
	 *****************************************************/
	const firebaseConfig = {
	  apiKey: "AIzaSyCaJZi1Bn1vbeKOC5cM3Gi6nOFyWaH4NK4",
	  authDomain: "animehub-7.firebaseapp.com",
	  projectId: "animehub-7",
	  storageBucket: "animehub-7.firebasestorage.app",
	  messagingSenderId: "159114039206",
	  appId: "1:159114039206:web:0461d676e7ffff25c4c967",
	  measurementId: "G-6K4MB0XQEV"
	};

	const app = initializeApp(firebaseConfig);
	const auth = getAuth(app);
	const db = getFirestore(app);
	
	/*****************************************************
	 * 3Ô∏è‚É£ VARIABLES & DOM
	 *****************************************************/
	const params = new URLSearchParams(window.location.search);
	const animeId = Number(params.get("id"));

	const img = document.getElementById("animeImg");
	const title = document.getElementById("animeTitle");
	const genresBox = document.getElementById("animeGenres");
	const ratingBox = document.getElementById("animeRating");
	const summary = document.getElementById("animeSummary");
	const favBtn = document.getElementById("favBtn");
	const rateSelect = document.getElementById("rateSelect");
	const toggleCanonBtn = document.getElementById("toggleCanonBtn");
	const watchStatus = document.getElementById("watchStatus");

	let currentAnime = null;
	let showNonCanon = false;
	/*****************************************************
	 * üîÑ LOADER
	 *****************************************************/
	const loader = document.getElementById("animeLoader");
	const content = document.getElementById("animeContent");
	const loadingText = document.getElementById("animeLoadingText");

	const loadingQuotes = [
	  "Les pages du carnet s‚Äô√©crivent‚Ä¶ üìì",
	  "L‚Äô√©nergie monte‚Ä¶ un Kamehameha se pr√©pare üí•",
	  "Revenir en arri√®re fait parfois plus mal que mourir‚Ä¶",
	  "Les murs tremblent‚Ä¶ la v√©rit√© approche ‚öîÔ∏è",
	  "Un √©change √©quivalent est en cours‚Ä¶ üî•",
	  "La guerre de l‚Äôamour a commenc√©‚Ä¶ qui avouera en premier ? ‚ôüÔ∏è",
	  "Le Nen circule‚Ä¶ l‚Äô√©preuve ne fait que commencer üéØ",
	  "Les fl√©aux s‚Äôagitent‚Ä¶ garde les yeux ouverts ü©∏",
	  "La ligne du monde est en train de changer‚Ä¶ üì°",
	  "Un ordre est sur le point d‚Äô√™tre donn√©‚Ä¶ üëÅÔ∏è",
	  "Les p√©ch√©s capitaux se rassemblent‚Ä¶ üç∫",
	  "Rien ne va se passer comme pr√©vu‚Ä¶ et c‚Äôest normal ü§°",
	  "Les √©motions atteignent 100%‚Ä¶ üí•",
	  "Bienvenue √† Night City‚Ä¶ accroche-toi ü¶æ",
	  "La volont√© du feu ne s‚Äô√©teint jamais üî•",
	  "Une m√©lodie s‚Äôappr√™te √† briser le silence‚Ä¶ üé∂",
	  "Les sentiments prennent forme doucement‚Ä¶",
	  "Le vent se l√®ve‚Ä¶ l‚Äôaventure continue üè¥‚Äç‚ò†Ô∏è",
	  "Un ph√©nom√®ne √©trange est sur le point d‚Äôappara√Ætre‚Ä¶",
	  "Les √¢mes s‚Äôagitent‚Ä¶ le combat est proche ‚ö°",
	  "Un coup suffira‚Ä¶ encore faut-il qu‚Äôil arrive üëä",
	  "Les mots manquent‚Ä¶ mais les √©motions parlent",
	  "Le match va reprendre‚Ä¶ ne cligne pas des yeux üèê",
	  "Derri√®re les projecteurs, la v√©rit√© se cache‚Ä¶",
	  "Une cr√©ation est en train de na√Ætre ‚úÇÔ∏è",
	  "Les petits moments font les plus belles histoires",
	  "Entre humanit√© et monstruosit√©‚Ä¶ le choix est flou",
	  "Le chaos arrive‚Ä¶ et √ßa va faire mal ü™ö",
	  "La douceur s‚Äôinstalle petit √† petit‚Ä¶",
	  "Derri√®re l‚Äôautorit√© se cache un c≈ìur tendre üíñ",
	  "Les souvenirs refont surface‚Ä¶ üéπ",
	  "Un nouveau niveau est sur le point d‚Äô√™tre atteint üî•",
	  "Les mal√©dictions se fissurent doucement‚Ä¶",
	  "Les relations sont rarement simples‚Ä¶",
	  "La lame se l√®ve‚Ä¶ pour prot√©ger les vivants ü©∏",
	  "Deux destins tentent de se reconnecter‚Ä¶",
	  "Tout va se jouer maintenant‚Ä¶ sans r√®gles üé≤",
	  "Les sentiments explosent sans pr√©venir",
	  "Un dieu fauch√© est pr√™t √† agir ‚ú®",
	  "Le pass√© attend d‚Äô√™tre corrig√©‚Ä¶",
	  "Le compte √† rebours a commenc√©‚Ä¶ ‚è≥",
	  "La strat√©gie se joue dans l‚Äôombre ‚ôüÔ∏è",
	  "Plus ultra‚Ä¶ le combat continue üí•",
	  "La taquinerie va encore frapper‚Ä¶",
	  "L‚Äôamour tente un retour inattendu‚Ä¶",
	  "Entre sport et sentiments, l‚Äô√©quilibre est fragile",
	  "M√™me √† la retraite, les l√©gendes frappent fort üòé",
	  "Chaque combat a un prix‚Ä¶ souvent mortel",
	  "Le sang d√©moniaque se r√©veille üî•",
	  "Le futur est d√©j√† en train de s‚Äô√©crire‚Ä¶ üìì",
	  "Les sentiments se cachent derri√®re un sourire",
	  "La connexion est presque √©tablie‚Ä¶ üéÆ",
	  "Le bizarre arrive‚Ä¶ et il ne plaisante pas",
	  "La magie de l‚Äôamiti√© fait encore des √©tincelles ‚ú®",
	  "Le plan est en marche‚Ä¶ silence total ü§´",
	  "Le jeu commence vraiment maintenant‚Ä¶",
	  "Le pass√© peut encore √™tre chang√©‚Ä¶",
	  "Une premi√®re fois pleine de surprises‚Ä¶",
	  "Une menace colossale approche‚Ä¶ üö®",
	  "La magie suit un chemin inattendu‚Ä¶",
	];

	function showAnimeLoader() {
	  loadingText.textContent =
		loadingQuotes[Math.floor(Math.random() * loadingQuotes.length)];
	  loader.style.display = "block";
	  content.style.display = "none";
	}

	function hideAnimeLoader() {
	  loader.style.display = "none";
	  content.style.display = "block";
	}

	/*****************************************************
	 * 4Ô∏è‚É£ UI HELPERS
	 *****************************************************/
	function updateFavUI(anime, animate = true) {
	  favBtn.classList.toggle("favorited", anime.fav);
	  favBtn.textContent = anime.fav ? "‚òÖ Favori" : "‚òÜ Favori";

	  if (!animate) return;
	  favBtn.classList.remove("pop");
	  void favBtn.offsetWidth;
	  favBtn.classList.add("pop");
	}

	function showToast(msg, type = "rate") {
	  const toast = document.getElementById("toast");
	  toast.textContent = msg;
	  toast.classList.toggle("remove", type === "remove");
	  toast.classList.add("show");
	  setTimeout(() => toast.classList.remove("show"), 2200);
	}
	function animateFavParticles(button) {
	  const rect = button.getBoundingClientRect();
	  const particles = [];
	  const count = 18;

	  for (let i = 0; i < count; i++) {
		particles.push({
		  x: rect.left + rect.width / 2,
		  y: rect.top + rect.height / 2,
		  dx: (Math.random() - 0.5) * 10,
		  dy: (Math.random() - 1.5) * 10,
		  size: Math.random() * 4 + 3,
		  life: 40
		});
	  }

	  const canvas = document.createElement("canvas");
	  canvas.width = window.innerWidth;
	  canvas.height = window.innerHeight;
	  canvas.style.position = "fixed";
	  canvas.style.top = 0;
	  canvas.style.left = 0;
	  canvas.style.pointerEvents = "none";
	  document.body.appendChild(canvas);

	  const ctx = canvas.getContext("2d");

	  function animate() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		particles.forEach(p => {
		  p.x += p.dx;
		  p.y += p.dy;
		  p.dy += 0.3;
		  ctx.fillStyle = "#ffd86b";
		  ctx.beginPath();
		  ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
		  ctx.fill();
		  p.life--;
		});

		if (particles.some(p => p.life > 0)) {
		  requestAnimationFrame(animate);
		} else {
		  document.body.removeChild(canvas);
		}
	  }
	  animate();
	}
	function playFavAnimation(button) {
	  button.classList.add("liked");
	  animateFavParticles(button);
	  setTimeout(() => button.classList.remove("liked"), 600);
	}
	function renderTimeline(anime) {
	  const timelineList = document.getElementById("timelineList");
	  if (!timelineList) return;
	  timelineList.innerHTML = "";

	  if (!anime.timeline || anime.timeline.length === 0) {
		timelineList.innerHTML = `
		  <div class="season-item empty">
			<span class="season-title">Timeline</span>
			<span class="season-episodes">Infos non disponibles</span>
		  </div>
		`;
		return;
	  }
      
	  const sortedTimeline = [...anime.timeline]
		.filter(item => showNonCanon || item.canon)
		.sort((a, b) => {
		  const dateA = a.releaseDate ? Date.parse(a.releaseDate) : 0;
		  const dateB = b.releaseDate ? Date.parse(b.releaseDate) : 0;
		  if (dateA !== dateB) return dateA - dateB;
		  return (a.title || "").localeCompare(b.title || "");
		});

	  sortedTimeline.forEach(item => {
		const div = document.createElement("div");
		div.className = "season-item";
		if (item.type === "movie") div.classList.add("movie");
		const icon =
		  item.type === "season" ? "üì∫" :
		  item.type === "movie"  ? "üé¨" :
		  item.type === "ova"    ? "‚≠ï" :
		  item.type === "special" ? "üí•" :
		  "‚ùì";

		div.innerHTML = `
		  <span class="season-title">
			${icon} ${item.title}
			${!item.canon ? '<span class="badge-non-canon">NON-CANON</span>' : ''}
			${item.status === "upcoming"
			  ? '<span class="badge-upcoming">UPCOMING</span>'
			  : ""}
		  </span>
		
		  <span class="season-episodes">
		    ${
			  item.type === "movie"
			    ? "MOVIE"
			    : item.episodes
				  ? `${item.episodes} √©pisodes`
				  : item.status === "upcoming"
				    ? "Prochainement"
				    : ""
		    }
		  </span>
		`;

		timelineList.appendChild(div);
	  });
	}
	function updateNonCanonButton(anime) {
	  if (!toggleCanonBtn) return;

	  if (!anime.timeline || anime.timeline.length === 0) {
		toggleCanonBtn.style.display = "none";
		return;
	  }

	  const hasCanon = anime.timeline.some(item => item.canon === true);
	  const hasNonCanon = anime.timeline.some(item => item.canon === false);

	  // afficher le bouton UNIQUEMENT s'il y a les deux
	  toggleCanonBtn.style.display =
		hasCanon && hasNonCanon ? "inline-flex" : "none";
	}
	/*****************************************************
	 * 5Ô∏è‚É£ FAVORIS
	 *****************************************************/
	async function syncFavoriteState(animeId) {
	  const user = auth.currentUser;
	  if (!user) return;

	  const snap = await getDoc(doc(db, "users", user.uid));
	  if (!snap.exists()) return;

	  const favorites = snap.data().favorites || [];
	  if (!currentAnime) return;

	  currentAnime.fav = favorites.includes(animeId);
	  updateFavUI(currentAnime, false);
	}

	async function toggleFavorite(animeId) {
	  const user = auth.currentUser;
	  if (!user) return;

	  const userRef = doc(db, "users", user.uid);
	  const animeRef = doc(db, "animes", String(animeId));

	  const userSnap = await getDoc(userRef);
	  const favorites = userSnap.data().favorites || [];

	  const alreadyFav = favorites.includes(animeId);

	  if (alreadyFav) {
	    await updateDoc(userRef, { favorites: arrayRemove(animeId) });
	    await updateDoc(animeRef, { likes: increment(-1) });
	    currentAnime.fav = false;

	    await sendNotification(
	  	  user.uid,
		  "üíî Favori retir√©",
		  currentAnime.title
	    );

	    showToast("üíî Retir√© des favoris", "remove");
	  } else {
	    await updateDoc(userRef, { favorites: arrayUnion(animeId) });
	    await updateDoc(animeRef, { likes: increment(1) });
	    currentAnime.fav = true;

	    await sendNotification(
		user.uid,
		  "‚≠ê Favori ajout√©",
		  currentAnime.title
	    );
	    showToast("‚ù§Ô∏è Ajout√© aux favoris");
	  }

	  if (currentAnime.fav) {
		playFavAnimation(favBtn); // ‚ù§Ô∏è + confettis
	  } else {
		favBtn.classList.add("removed"); // üíî
		setTimeout(() => favBtn.classList.remove("removed"), 500);
	  }

	  updateFavUI(currentAnime, false); // pas de double anim
	  }

	async function syncUserData(animeId) {
	  const user = auth.currentUser;
	  if (!user) return;

	  const userSnap = await getDoc(doc(db, "users", user.uid));
	  if (!userSnap.exists()) return;

	  const data = userSnap.data();

	  /* FAVORIS */
	  const favorites = data.favorites || [];
	  currentAnime.fav = favorites.includes(animeId);
	  updateFavUI(currentAnime, false); // ‚ùå PAS d'animation au chargement

	  /* NOTE */
	  const userRating = data.ratings?.[animeId] ?? null;
	  if (userRating !== null) {
		rateSelect.value = userRating;
		rateSelect.classList.add("rated");
	  } else {
		rateSelect.value = "";
		rateSelect.classList.remove("rated");
	  }

	  /* STATUT */
	  const status = data.statuses?.[animeId] ?? null;
	  updateStatusUI(status);
	}

	function updateStatusUI(status) {
	  if (!watchStatus) return;
	  const buttons = watchStatus.querySelectorAll(".status-btn");
	  buttons.forEach(button => {
		button.classList.toggle("is-active", button.dataset.status === status);
	  });
	}

	async function setWatchStatus(animeId, status) {
	  const user = auth.currentUser;
	  if (!user) return;
	  const userRef = doc(db, "users", user.uid);
	  await updateDoc(userRef, { [`statuses.${animeId}`]: status });
	  updateStatusUI(status);
	  showToast(`Statut: ${status === "completed" ? "Termin√©" : status === "watching" ? "En cours" : "√Ä voir"}`);
	}
	/*****************************************************
	 * 6Ô∏è‚É£ NOTES
	 *****************************************************/
	async function rateAnime(animeId, newRating) {
	  const user = auth.currentUser;
	  if (!user) return;

	  const userRef = doc(db, "users", user.uid);
	  const animeRef = doc(db, "animes", String(animeId));

	  const userSnap = await getDoc(userRef);
	  const animeSnap = await getDoc(animeRef);

	  const oldRating = userSnap.data().ratings?.[animeId] ?? null;
	  let ratingSum = animeSnap.data()?.ratingSum ?? 0;
	  let ratingCount = animeSnap.data()?.ratingCount ?? 0;

	  if (oldRating === null) {
		ratingSum += newRating;
		ratingCount++;
	  } else {
		ratingSum += (newRating - oldRating);
	  }
	  await sendNotification(
	    user.uid,
	    "üìù Anime not√©",
	    `${currentAnime.title} ‚Äî ${newRating}/10`
	  );

	  const avgRating = ratingSum / ratingCount;

	  await setDoc(animeRef, { ratingSum, ratingCount, avgRating }, { merge: true });
	  await updateDoc(userRef, { [`ratings.${animeId}`]: newRating });

	  currentAnime.rating = avgRating;
	  ratingBox.textContent = `‚≠ê ${avgRating.toFixed(1)}`;
	}

	async function removeRating(animeId) {
	  const user = auth.currentUser;
	  if (!user) return;

	  const userRef = doc(db, "users", user.uid);
	  const animeRef = doc(db, "animes", String(animeId));

	  const userSnap = await getDoc(userRef);
	  const animeSnap = await getDoc(animeRef);

	  const oldRating = userSnap.data().ratings?.[animeId];
	  if (oldRating == null) return;

	  let { ratingSum = 0, ratingCount = 0 } = animeSnap.data();
	  ratingSum -= oldRating;
	  ratingCount--;

	  const avgRating = ratingCount > 0 ? ratingSum / ratingCount : 0;

	  await setDoc(animeRef, { ratingSum, ratingCount, avgRating }, { merge: true });
	  await updateDoc(userRef, { [`ratings.${animeId}`]: deleteField() });

	  ratingBox.textContent = avgRating ? `‚≠ê ${avgRating.toFixed(1)}` : "Pas encore not√©";
	  rateSelect.value = "";
	  
	  await sendNotification(
	    user.uid,
	    "‚ùå Note supprim√©e",
	    currentAnime.title
	  );
	}
	// üîπ Remplir le select de notes
	rateSelect.innerHTML = '<option value="">Noter</option>';
	for (let i = 0.5; i <= 10; i += 0.5) {
	  const opt = document.createElement("option");
	  opt.value = i;
	  opt.textContent = i;
	  rateSelect.appendChild(opt);
	}
	/*****************************************************
	 * 7Ô∏è‚É£ NOTIFICATIONS‚êä
	 *****************************************************/
	async function sendNotification(userId, title, message = "") {
	  try {
		await addDoc(collection(db, "notifications"), {
		  userId: userId,
		  title: title,
		  message: message,
		  read: false,
		  createdAt: serverTimestamp()
		});
	  } catch (err) {
		console.error("Erreur notification:", err);
	  }
	}
	async function fetchAnimeFromFirestore(animeId) {
	  const animeSnap = await getDoc(doc(db, "animes", String(animeId)));
	  if (!animeSnap.exists()) return null;

	  const data = animeSnap.data();
	  const anilistScore = Number.isFinite(data.anilistScore)
		? data.anilistScore / 10
		: null;
	  const rating = Number.isFinite(data.avgRating)
		? data.avgRating
		: anilistScore;
	  return {
		id: Number(animeId),
		title: data.title || "Anime",
		genre: data.genre || [],
		rating,
		anilistScore,
		year: data.seasonYear || data.year || null,
		img: data.img || "icon_animehub.png",
		summary: data.summary || "Synopsis indisponible.",
		fav: false,
		likes: data.likes || 0,
		timeline: data.timeline || []
	  };
	}
	/*****************************************************
	 * 79‚É£ INIT PAGE
	 *****************************************************/
	showAnimeLoader();
	onAuthStateChanged(auth, async (user) => {
	  if (!user) return;

	  currentAnime = await fetchAnimeFromFirestore(animeId);
	  if (!currentAnime) return;
	  /* üé® INFOS ANIME (UNE SEULE FOIS) */
	  img.src = currentAnime.img;
	  img.alt = currentAnime.title;
	  title.textContent = currentAnime.title;
	  summary.textContent = currentAnime.summary;
	  renderTimeline(currentAnime);
	  if (toggleCanonBtn) {
	    toggleCanonBtn.textContent = "Afficher le non-canon";

	    toggleCanonBtn.onclick = () => {
		  showNonCanon = !showNonCanon;
		  toggleCanonBtn.classList.toggle("active", showNonCanon);
		  toggleCanonBtn.textContent = showNonCanon
		    ? "Masquer le non-canon"
		    : "Afficher le non-canon";

		  renderTimeline(currentAnime);
	    };
	  }
	  updateNonCanonButton(currentAnime);
	  /* üé≠ GENRES CLIQUABLES */
	  genresBox.innerHTML = "";
	  currentAnime.genre.forEach(g => {
		const a = document.createElement("a");
		a.textContent = g;
		a.href = `index.html?genre=${encodeURIComponent(g)}`;
		genresBox.appendChild(a);
	  });

	  if (Number.isFinite(currentAnime.rating)) {
		ratingBox.textContent = `‚≠ê ${currentAnime.rating.toFixed(1)}`;
	  } else {
		ratingBox.textContent = "N/A";
	  }
	  img.src = currentAnime.img;
	  title.textContent = currentAnime.title;
	  summary.textContent = currentAnime.summary;

	  await syncUserData(animeId);

	  favBtn.onclick = () => toggleFavorite(animeId);
	  watchStatus?.addEventListener("click", (event) => {
		const button = event.target.closest(".status-btn");
		if (!button) return;
		setWatchStatus(animeId, button.dataset.status);
	  });
	  rateSelect.addEventListener("change", e => {
		if (e.target.value === "") {
		  removeRating(animeId);
		  rateSelect.classList.remove("rated");
		} else {
		  rateAnime(animeId, Number(e.target.value));
		  rateSelect.classList.add("rated");
		}
	  });
	  hideAnimeLoader();
	  });
  </script>
</body>
</html>
