<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AnimeHub - Profil</title>
  <style>
    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: linear-gradient(180deg, #0b1220, #061226);
      color: #e6eef6;
      min-height: 100vh;
      transition: background 0.5s ease;
    }

    .profile-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      padding: 30px 20px;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: rgba(255,255,255,0.05);
      backdrop-filter: blur(10px);
      border-radius: 18px;
      padding: 25px 20px;
      box-shadow: 0 15px 30px rgba(0,0,0,0.55);
      display: flex;
      flex-direction: column;
      min-height: 150px;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      opacity: 0;
      transform: translateY(20px);
      animation: fadeUp 0.6s ease-out forwards;
      border: 1px solid rgba(255,255,255,0.06);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 45px rgba(0,0,0,0.75);
    }

    .avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      color: #052226;
      font-size: 40px;
      font-weight: 800;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 18px;
      background: linear-gradient(135deg, #06b6d4, #3b82f6);
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 0 4px rgba(6,182,212,0.25);
    }

    .pulsing::before {
      content: '';
      position: absolute;
      width: 140%;
      height: 140%;
      border-radius: 50%;
      background: rgba(6,182,212,0.5);
      animation: pulseGlow 2s infinite ease-in-out;
      top: -20%;
      left: -20%;
      z-index: 0;
    }

    @media (prefers-reduced-motion: reduce) {
      .pulsing::before {
        animation: none;
      }
    }

    .avatar span {
      position: relative;
      z-index: 1;
    }

    @keyframes pulseGlow {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.2); opacity: 1; }
    }

    h2, .email, .bio {
      margin: 0;
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
    }

    .fade-in { opacity: 1 !important; }

    .email {
      color: #9ca3af;
      font-size: 14px;
      margin: 8px 0 10px;
    }

    .bio {
      font-size: 13px;
      color: #c0c8d6;
      margin-bottom: 12px;
      text-align: center;
    }

    h3 { font-size: 17px; margin-bottom: 12px; }

    .stats { display: flex; justify-content: space-between; gap: 12px; margin-top: 12px; }

    .stat { flex: 1; background: rgba(255,255,255,0.08); border-radius: 14px; padding: 12px; text-align: center; transition: background 0.3s ease; backdrop-filter: blur(6px); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06); }

    .stat:hover { background: rgba(6,182,212,0.2); }

    .stat-value { font-size: 22px; font-weight: 800; color: #06b6d4; }

    .stat-label { font-size: 13px; color: #9ca3af; }

    .rated-list { display: flex; justify-content: space-between; flex-direction: column; gap: 10px; max-height: 250px; overflow-y: auto; padding-right: 5px; }

    .rated-list::-webkit-scrollbar { width: 6px; }
    .rated-list::-webkit-scrollbar-thumb { background: #06b6d4; border-radius: 3px; }

	.rated-item {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
	  background: rgba(255,255,255,0.08);
	  padding: 10px 12px;
	  border-radius: 12px;
	  border: 1px solid rgba(255,255,255,0.05);
	  cursor: pointer;
	  transition: background 0.3s ease, transform 0.2s ease;
	  opacity: 0;
	  transform: translateY(10px);
	  animation: fadeUp 0.4s ease-out forwards;
	}

    .rated-item:hover {
	  background: rgba(6,182,212,0.15);
	  transform: translateY(-2px);
	}

    .rated-title {
	  font-size: 14px;
	  font-weight: 600;
	  flex: 1; /* prend tout l‚Äôespace disponible */
	  overflow: hidden;
	  text-overflow: ellipsis;
	  white-space: nowrap;
	}

    .rated-right {
	  display: flex;
	  align-items: center;
	  gap: 10px;
	}
	
	.rated-left {
	  display: flex;
	  align-items: center;
	  gap: 12px; /* ‚Üê espace entre nom et note */
	}

    .rated-score {
	  font-weight: 800;
	  color: #06b6d4;
	  min-width: 24px;
	  text-align: center;
	}

    .rated-btn {
	  font-size: 12px;
	  padding: 4px 8px;
	  border-radius: 6px;
	  border: 1px solid rgba(255,255,255,0.2);
	  background: transparent;
	  color: #e6eef6;
	  cursor: pointer;
	  transition: background 0.3s ease, color 0.3s ease, transform 0.2s ease;
	}

    .rated-btn:hover {
	  background: #06b6d4;
	  color: #052226;
	  transform: translateY(-1px);
	}

    .reco-modes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }

    .reco-modes button {
      background: rgba(255,255,255,0.08);
      color: #e6eef6;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .reco-modes button.active {
      background: #06b6d4;
      color: #052226;
      border-color: transparent;
      box-shadow: 0 6px 18px rgba(6,182,212,0.4);
    }

    .notes-card { grid-column: 1 / -1; margin-top: 10px; }

    .actions-card { display: flex; gap: 12px; justify-content: center; flex-direction: column; }

    button { padding: 12px; border-radius: 12px; border: none; cursor: pointer; font-weight: 700; background: #06b6d4; color: #052226; transition: transform 0.2s ease, background 0.3s ease; transform: translateY(0); }

    button:hover { transform: translateY(-2px); background: #3b82f6; }

    .secondary { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #e6eef6; }

    #topBtn { position: fixed; bottom: 22px; right: 22px; padding: 10px 14px; font-size: 16px; border-radius: 10px; background-color: #06b6d4; color: #052226; border: none; cursor: pointer; font-weight: 700; display: none; box-shadow: 0 6px 20px rgba(6,182,212,0.35); transition: opacity 0.2s ease, transform 0.2s ease, background 0.3s ease; }

    #topBtn:hover { background-color: #3b82f6; transform: translateY(-2px); }
    #topBtn.show { display: inline-flex; align-items: center; justify-content: center; }
    #topBtn.hide { opacity: 0; transform: translateY(8px); }

    .favorites-card, .badges-card, .reco-card { min-height: 200px; margin-top: 10px; }

    .badges-list, .reco-list { display: flex; gap: 10px; flex-wrap: wrap; }

    .badge { padding: 6px 10px; border-radius: 10px; background: rgba(6,182,212,0.3); font-size: 12px; font-weight: 600; }

    @keyframes fadeUp { to { opacity: 1; transform: translateY(0); } }
    @keyframes fadeRight {
	  to { opacity: 1; transform: translateX(0); }
	}

    @media (max-width: 600px) {
      .profile-grid { padding: 20px 14px; }
      .avatar { width: 80px; height: 80px; font-size: 32px; }
      .stat-value { font-size: 18px; }
    }
	/* ----- BADGES ----- */
	.badge {
	  display: inline-block;
	  padding: 6px 12px;
	  margin: 4px 4px 0 0;
	  background: linear-gradient(135deg, #06b6d4, #3b82f6);
	  color: #fff;
	  font-size: 12px;
	  font-weight: 600;
	  border-radius: 20px;
	  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
	  transition: transform 0.2s ease, background 0.3s ease;
	  cursor: default;
	}
	.badge:hover {
	  transform: translateY(-2px) scale(1.05);
	  background: linear-gradient(135deg, #3b82f6, #06b6d4);
	}
	.bio-mini {
	  display: flex;
	  align-items: center;
	  gap: 6px;
	  font-size: 13px;
	  color: #e6eef6;
	}

	.bio-mini button {
	  background: transparent;
	  border: none;
	  color: #06b6d4;
	  cursor: pointer;
	  font-size: 14px;
	}

	#bioInput {
	  width: 100%;
	  min-height: 40px;
	  padding: 6px 8px;
	  border-radius: 8px;
	  border: 1px solid rgba(255,255,255,0.2);
	  background: rgba(255,255,255,0.05);
	  color: #e6eef6;
	  font-size: 13px;
	  resize: vertical;
	}

	#saveBioBtn, #cancelBioBtn {
	  padding: 4px 8px;
	  font-size: 12px;
	  border-radius: 8px;
	  font-weight: 700;
	  cursor: pointer;
	  margin-right: 4px;
	  border: none;
	}

	.bio-actions {
	  display: flex;
	  gap: 8px;
	  margin-top: 8px;
	}

	#saveBioBtn { background: #06b6d4; color: #052226; }
	#saveBioBtn:hover { background: #3b82f6; }

	#cancelBioBtn { background: transparent; color: #e6eef6; border: 1px solid rgba(255,255,255,0.3); }
	#cancelBioBtn:hover { background: rgba(255,255,255,0.1); }
	.tag {
	  margin-left: 6px;
	  font-size: 11px;
	  padding: 2px 6px;
	  border-radius: 6px;
	  background: rgba(6,182,212,0.15);
	  color: #06b6d4;
	  font-weight: 600;
	}
	.reco-list {
	  display: grid;
	  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
	  gap: 12px;
	  padding: 10px 0;
	}
	.reco-reasons {
	  margin-top: 4px;
	  display: flex;
	  flex-wrap: wrap;
	  gap: 6px;
	}

	.reco-reason {
	  font-size: 11px;
	  padding: 3px 7px;
	  border-radius: 999px;
	  background: rgba(255,255,255,0.08);
	  color: #cbd5f5;
	  opacity: 0.85;
	}
	.reco-card.wide {
	  grid-column: span 2;
	}
	@media (max-width: 900px) {
	  .reco-card.wide {
		grid-column: 1 / -1;
	  }
	}
	body {
      opacity: 1;
      transition: opacity 0.6s ease;
    }

    body.fonts-not-loaded {
      opacity: 0;
    }

    button:focus-visible,
    .rated-btn:focus-visible,
    #topBtn:focus-visible,
    #bioInput:focus-visible {
      outline: 2px solid rgba(6,182,212,0.9);
      outline-offset: 2px;
    }
  </style>
</head>
<body class="fonts-not-loaded">
  <!-- Top Grid : Profil + Stats + Actions -->
  <div class="profile-grid top-grid">
    <div class="card profile-card">
      <div class="avatar pulsing" id="avatar">?</div>
      <h2 id="username">Chargement...</h2>
      <div class="email" id="email">Chargement...</div>
      <div class="bio-mini">
	    <span id="bioText">Aucune bio pour l‚Äôinstant.</span>
	    <button id="editBioBtn" aria-label="Modifier la bio" title="Modifier la bio">‚úèÔ∏è</button>
	  </div>

	  <div id="bioEditContainer" style="display:none;">
	    <textarea id="bioInput" placeholder="√âcris ta bio ici..."></textarea>
        <div class="bio-actions">
	      <button id="saveBioBtn" aria-label="Sauvegarder la bio" title="Sauvegarder">üíæ</button>
	      <button id="cancelBioBtn" aria-label="Annuler la modification" title="Annuler">‚ùå</button>
	    </div>
	  </div>
    </div>
	
    <div class="card stats-card">
      <h3>Mes Statistiques</h3>
      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="stat-rated">‚Äì</div>
          <div class="stat-label">Not√©s</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-favs">‚Äì</div>
          <div class="stat-label">Favoris</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-avg">‚Äì</div>
          <div class="stat-label">Moyenne</div>
        </div>
      </div>
    </div>

    <div class="card actions-card">
      <button onclick="location.href='index.html'">Retour √† l‚Äôaccueil</button>
      <button class="secondary" id="logoutBtn">D√©connexion</button>
    </div>
  </div>

  <!-- Notes + Favoris + Badges + Recommandations -->
  <div class="profile-grid">
    <div class="card notes-card">
      <h3>Mes notes</h3>
      <div class="rated-list" id="ratedList"></div>
    </div>

    <div class="card favorites-card">
      <h3>Mes favoris</h3>
      <div class="rated-list" id="favoritesList"></div>
    </div>

    <div class="card badges-card">
	  <h3>Mes badges</h3>
	  <div id="badgesList"></div>
	</div>

    <div class="card reco-card wide">
	  <h3>Suggestions pour toi</h3>
	  <div class="reco-modes">
	    <button data-mode="smart" class="active">üéØ Intelligent</button>
	    <button data-mode="safe">üõ°Ô∏è S√ªr</button>
	    <button data-mode="explore">üåç Explorer</button>
	    <button data-mode="community">üë• Communaut√©</button>
	  </div>
      <div class="reco-list" id="recoList">
        <!-- Mini-cards recommand√©es -->
      </div>
    </div>
  </div>

  <button id="topBtn" title="Retour en haut">‚Üë Top</button>
  <script>
	window.ANIMES = [];

	// R√©cup√®re le bouton
	const topBtn = document.getElementById("topBtn");
	topBtn.classList.add("hide");

	// Affiche le bouton quand on scroll de 200px
	window.addEventListener("scroll", () => {
	  if (document.documentElement.scrollTop > 200) {
		topBtn.classList.add("show");
		topBtn.classList.remove("hide");
	  } else {
		topBtn.classList.add("hide");
		setTimeout(() => topBtn.classList.remove("show"), 200);
	  }
	});

	// Scroll vers le haut au clic
	topBtn.addEventListener("click", () => {
	  window.scrollTo({ top: 0, behavior: 'smooth' });
	});
    document.fonts.ready.then(() => {
      document.body.classList.remove("fonts-not-loaded");
    });
  </script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, collection, getDocs } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyCaJZi1Bn1vbeKOC5cM3Gi6nOFyWaH4NK4",
      authDomain: "animehub-7.firebaseapp.com",
      projectId: "animehub-7",
      storageBucket: "animehub-7.firebasestorage.app",
      messagingSenderId: "159114039206",
      appId: "1:159114039206:web:0461d676e7ffff25c4c967"
    };
  
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    const usernameEl = document.getElementById("username");
    const emailEl = document.getElementById("email");
    const avatarEl = document.getElementById("avatar");
	
	let userTaste = {
	  topGenres: [],
	  dislikedGenres: [],
	  precision: "normal"
	};

	let minRating = 6;
	let userLikeYouAnimes = {};
	let recoMode = "smart";

	async function loadAnimesFromFirestore() {
	  try {
		const animesSnap = await getDocs(collection(db, "animes"));
		const firestoreAnimes = animesSnap.docs.map((docSnap) => {
		  const data = docSnap.data();
		  return {
			id: Number(docSnap.id),
			title: data.title || "Anime sans titre",
			genre: Array.isArray(data.genre) ? data.genre : [],
			rating: Number.isFinite(data.avgRating)
			  ? data.avgRating
			  : (Number.isFinite(data.anilistScore) ? data.anilistScore / 10 : 0),
			avgRating: Number.isFinite(data.avgRating)
			  ? data.avgRating
			  : (Number.isFinite(data.anilistScore) ? data.anilistScore / 10 : null),
			year: data.seasonYear || data.year || null,
			img: data.img || "icon_animehub.png",
			summary: data.summary || "",
			fav: false,
			likes: data.likes || 0,
			createdAt: data.createdAt || null
		  };
		});

		if (firestoreAnimes.length) {
		  window.ANIMES = firestoreAnimes;
		}
	  } catch (err) {
		console.warn("Impossible de charger les animes Firestore, liste vide utilis√©e.", err);
	  }
	}

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "auth.html";
        return;
      }

	  await loadAnimesFromFirestore();
	  const usersSnap = await getDocs(collection(db, "users"));

      const userRef = doc(db, "users", user.uid);
      let userData = {};

      try {
        const snap = await getDoc(userRef);

        if (!snap.exists()) {
          userData = {
            username: user.email.split("@")[0],
            email: user.email,
            favorites: [],
            ratings: {}
          };
          await setDoc(userRef, userData);
        } else {
          userData = snap.data();
        }

        const name = userData.username || user.email.split("@")[0];

        usernameEl.textContent = name;
        emailEl.textContent = userData.email || user.email;
        avatarEl.textContent = name.charAt(0).toUpperCase();
        avatarEl.classList.remove("pulsing");
        usernameEl.classList.add("fade-in");
        emailEl.classList.add("fade-in");

        // üîπ STATS
        const ratings = userData.ratings || {};
        const favorites = userData.favorites || [];

        const ratedCount = Object.keys(ratings).length;
        let avg = "‚Äì";
        if (ratedCount > 0) {
          const sum = Object.values(ratings).reduce((a, b) => a + b, 0);
          avg = (sum / ratedCount).toFixed(1);
        }
        const favCount = favorites.length;

        document.getElementById("stat-rated").textContent = ratedCount;
        document.getElementById("stat-favs").textContent = favCount;
        document.getElementById("stat-avg").textContent = avg;

		// üîπ BIO
		const bioText = document.getElementById("bioText");
		const bioInput = document.getElementById("bioInput");
		const editBioBtn = document.getElementById("editBioBtn");
		const saveBioBtn = document.getElementById("saveBioBtn");
		const cancelBioBtn = document.getElementById("cancelBioBtn");
		const bioEditContainer = document.getElementById("bioEditContainer");

		// Charger la bio depuis Firestore
		bioText.textContent = userData.bio || "Aucune bio pour l‚Äôinstant.";
		bioInput.value = userData.bio || "";

		// √âditer
		editBioBtn.addEventListener("click", () => {
		  bioEditContainer.style.display = "block";
		  bioInput.focus();
		});

		// Annuler
		cancelBioBtn.addEventListener("click", () => {
		  bioInput.value = userData.bio || "";
		  bioEditContainer.style.display = "none";
		});

		// Sauvegarder
		saveBioBtn.addEventListener("click", async () => {
		  const bio = bioInput.value.trim();
		  await setDoc(doc(db, "users", auth.currentUser.uid), { bio }, { merge: true });
		  userData.bio = bio;
		  bioText.textContent = bio || "Aucune bio pour l‚Äôinstant.";
		  bioEditContainer.style.display = "none";
		});

		// üîπ BADGES
		const badgesListEl = document.getElementById("badgesList");
		badgesListEl.innerHTML = "";

		// R√©cup√®re les badges existants ou initialise
		let badges = userData.badges || [];

		// Logique d'attribution de badges selon stats
		if (ratedCount >= 10 && !badges.includes("Anime Addict")) badges.push("Anime Addict");
		if (avg !== "‚Äì" && avg >= 8 && !badges.includes("Shonen Master")) badges.push("Shonen Master");
		if (ratedCount === 0 && !badges.includes("D√©butant")) badges.push("D√©butant");
		if (ratedCount >= 25 && !badges.includes("Otaku confirm√©")) badges.push("Otaku confirm√©");
		if (ratedCount >= 50 && !badges.includes("No Life (assum√©)")) badges.push("No Life (assum√©)");
		if (avg <= 6 && !badges.includes("Critique exigeant")) badges.push("Critique exigeant");
	    if (avg >= 9 && !badges.includes("√âlite Otaku")) badges.push("√âlite Otaku");
		if (favCount >= 10 && !badges.includes("Collectionneur")) badges.push("Collectionneur");
		
		// Affiche les badges
		if (badges.length === 0) {
		  badgesListEl.innerHTML = `<div style="opacity:.6; font-size:14px;">Aucun badge pour l‚Äôinstant</div>`;
		} else {
		  badges.forEach(b => {
			const div = document.createElement("div");
			div.className = "badge";
			div.textContent = b;
			badgesListEl.appendChild(div);
		  });
		}

		// Optionnel : mettre √† jour Firestore avec les badges calcul√©s
		await setDoc(doc(db, "users", auth.currentUser.uid), { badges }, { merge: true });
		
		// üîπ PROFIL DE GO√õT UTILISATEUR (Niveau 3)

		const genreStats = {}; // { genre: score }
		// Analyse des notes
		Object.entries(ratings).forEach(([id, note]) => {
		  const anime = window.ANIMES.find(a => a.id === parseInt(id));
		  if (!anime) return;
		  anime.genre.forEach(g => {
			if (!genreStats[g]) genreStats[g] = 0;
			if (note >= 8) genreStats[g] += 10;
			else if (note >= 6) genreStats[g] += 5;
			else genreStats[g] -= 6; // p√©nalit√©
		  });
		});
		// Analyse des favoris
		favorites.forEach(id => {
		  const anime = window.ANIMES.find(a => a.id === id);
		  if (!anime) return;
		  anime.genre.forEach(g => {
			if (!genreStats[g]) genreStats[g] = 0;
			genreStats[g] += 12;
		  });
		});
		// Classement des genres
		const sortedGenres = Object.entries(genreStats)
		  .sort((a, b) => b[1] - a[1]);
		const topGenres = sortedGenres
		  .filter(([_, score]) => score > 0)
		  .slice(0, 3)
		  .map(([g]) => g);
		const dislikedGenres = sortedGenres
		  .filter(([_, score]) => score < -5)
		  .map(([g]) => g);
		// Optionnel : profil de pr√©cision
		let precision = "normal";
		if (avg >= 8.5) precision = "exigeant";
		if (avg <= 6) precision = "large";
		userTaste.topGenres = topGenres;
		userTaste.dislikedGenres = dislikedGenres;
		userTaste.precision = precision;

		// üîπ SEUIL DE QUALIT√â MINIMUM

		minRating = 6;
		if (precision === "exigeant") minRating = 7.5;
		if (precision === "large") minRating = 5.5;
		
		const similarUsers = [];
		usersSnap.forEach(docSnap => {
		  if (docSnap.id === auth.currentUser.uid) return;

		  const other = docSnap.data();
		  if (!other.ratings) return;

		  let score = 0;
		  let common = 0;

		  Object.entries(ratings).forEach(([animeId, myNote]) => {
			if (other.ratings[animeId]) {
			  score += 10 - Math.abs(myNote - other.ratings[animeId]);
			  common++;
			}
		  });

		  if (common >= 3 && score >= 20) {
			similarUsers.push({ uid: docSnap.id, score, data: other });
		  }
		});
		userLikeYouAnimes = {};
		similarUsers.forEach(u => {
		  Object.entries(u.data.ratings || {}).forEach(([id, note]) => {
			const animeId = parseInt(id);
			if (ratings[animeId] || favorites.includes(animeId)) return;
			if (note >= 8) {
			  userLikeYouAnimes[animeId] =
				(userLikeYouAnimes[animeId] || 0) + u.score;
			}
		  });

		  (u.data.favorites || []).forEach(id => {
			if (!ratings[id] && !favorites.includes(id)) {
			  userLikeYouAnimes[id] =
				(userLikeYouAnimes[id] || 0) + 15;
			}
		  });
		});

		function renderRecommendations() {
		  const baseAnimes = window.ANIMES.map(a => ({
		    ...a,
		    surpriseScore: 0
		  }));
		  const excludedIds = [
		    ...Object.keys(ratings).map(id => parseInt(id)),
		    ...favorites
		  ];
		  // üîπ Genre dominant (celui que l'utilisateur consomme le plus)
		  const dominantGenre = userTaste.topGenres[0] || null;

		  // 1Ô∏è‚É£ Construire le profil de go√ªt (genres pond√©r√©s)
		  const genreWeights = {};

		  baseAnimes.forEach(anime => {
		    if (ratings[anime.id]) {
			  // anime not√©
			  anime.genre.forEach(g => {
			    if (!genreWeights[g]) genreWeights[g] = 0;
			    genreWeights[g] += ratings[anime.id]; // note = poids
			  });
		    }
		    if (favorites.includes(anime.id)) {
			  // favori = bonus fort
			  anime.genre.forEach(g => {
			    if (!genreWeights[g]) genreWeights[g] = 0;
			    genreWeights[g] += 10;
			  });
		    }
		  });
		  // 2Ô∏è‚É£ Calcul du score de reco
		  const recoAnimes = baseAnimes
		  .filter(a => !excludedIds.includes(a.id))
		  .map(a => {
			let score = 0;
			const reasons = [];

			if ((a.rating || 0) < minRating) return null;

			a.genre.forEach(g => {
			  if (userTaste.topGenres.includes(g)) {
				score += 18;
				reasons.push(`Tu aimes le genre ${g}`);
			  }
			  if (userTaste.dislikedGenres.includes(g)) score -= 30;
			});

			if (userLikeYouAnimes[a.id]) {
			  score += Math.min(userLikeYouAnimes[a.id] / 5, 25);
			  reasons.push("Appr√©ci√© par des utilisateurs similaires √† toi");
			}

			if ((a.avgRating ?? 0) >= 8) {
			  reasons.push(`Tr√®s bien not√© (${a.avgRating.toFixed(1)})`);
			}

			score += (a.rating || 0) * 0.6;

			return { ...a, score, reasons };
		  })
		  .filter(Boolean)
		  .sort((a, b) => b.score - a.score);

		  function renderExplorer(recoAnimes) {
		    const shuffled = [...recoAnimes].sort((a, b) => {
			  const da = !a.genre.some(g => userTaste.topGenres.includes(g));
			  const db = !b.genre.some(g => userTaste.topGenres.includes(g));

			  return (
			    (b.surpriseScore || 0) +
			    (db ? 30 : 0) -
			    (a.surpriseScore || 0) -
			    (da ? 30 : 0)
			  );
		    });

		    return shuffled.slice(0, 6);
		  }

		  const mainReco = [];
		  const diversityReco = [];

		  recoAnimes.forEach(a => {
		    const isTop = a.genre.some(g => userTaste.topGenres.includes(g));
		    const isDisliked = a.genre.some(g => userTaste.dislikedGenres.includes(g));

		    if (isDisliked) return;

		    if (isTop) {
			  mainReco.push(a);
		    } else if ((a.rating || 0) >= minRating + 0.3) {
			  diversityReco.push(a);
		    }
		  });
		  const FINAL_LIMIT = 6;
		  let DIVERSITY_QUOTA = 2;
		  if (recoMode === "explore") DIVERSITY_QUOTA = 4;
		  if (recoMode === "safe") DIVERSITY_QUOTA = 1;
		  
		  const finalReco = [
		    ...mainReco.slice(0, FINAL_LIMIT - DIVERSITY_QUOTA),
		    ...diversityReco.slice(0, DIVERSITY_QUOTA)
		  ];
		
		  const uniqueGenreReco = [];
		  const usedGenres = {};

		  for (const anime of recoAnimes) {
		    const mainGenre = anime.genre[0]; // genre principal

		    if (!usedGenres[mainGenre]) {
		  	  usedGenres[mainGenre] = true;
			  uniqueGenreReco.push(anime);
		    }

		    if (uniqueGenreReco.length >= 6) break;
		  }
		  const finalRecoIds = new Set(finalReco.map(a => a.id));
		  const surpriseCandidates = baseAnimes
		    .filter(a => {
			  if (excludedIds.includes(a.id)) return false;
			  if (finalRecoIds.has(a.id)) return false; // üî• FIX IMPORTANT
			  if ((a.rating ?? 0) < minRating) return false;
			  return userLikeYouAnimes[a.id] >= 15;
		    });

		  surpriseCandidates.forEach(a => {
		    let surpriseScore = 0;
		  
		    // + score si genre proche de ses pr√©f√©rences
		    a.genre.forEach(g => {
			  if (userTaste.topGenres.includes(g)) surpriseScore += 5;
			  if (userTaste.dislikedGenres.includes(g)) surpriseScore -= 10;
		    });

		    // + score bas√© sur popularit√© chez autres utilisateurs
		    if (userLikeYouAnimes[a.id]) surpriseScore += Math.min(userLikeYouAnimes[a.id] / 3, 20);

		    // bonus pour nouveaut√©
		    if (a.createdAt && ((Date.now() - a.createdAt.toMillis()) < 1000*60*60*24*30)) {
			  surpriseScore += 10; // ajout√© si anime < 30 jours
		    }
		    a.surpriseScore = surpriseScore;
		  });
		  const seenGenres = new Set();

		  const filteredReco = recoAnimes.filter(a => {
		    const g = a.genre[0];
		    if (seenGenres.has(g)) return false;
		    seenGenres.add(g);
		    return true;
		  });

		  const surprises = surpriseCandidates
		    .sort((a,b) => b.surpriseScore - a.surpriseScore)
		    .slice(0, 2); // max 2 surprises

		  const finalRecoWithSurprise = [
		    ...finalReco.filter(a => !surprises.some(s => s.id === a.id))
		  ];
		  for (const s of surprises) {
		    if (finalRecoWithSurprise.length < FINAL_LIMIT) {
			  finalRecoWithSurprise.push(s);
		    }
		  }
		  // s√©curit√© ultime
		  finalRecoWithSurprise.length = FINAL_LIMIT;

		  // 3Ô∏è‚É£ Affichage
		  const recoListEl = document.getElementById("recoList");
		  recoListEl.innerHTML = "";

		  finalRecoWithSurprise.forEach(a => {
		    const isDiscovery = !a.genre.some(g => userTaste.topGenres.includes(g));
		    const surpriseIds = new Set(surprises.map(s => s.id));
		    const isSurprise = surpriseIds.has(a.id);
		    const reasonsHtml = (a.reasons || [])
		      .slice(0, 2) // max 2 raisons (lisible)
		      .map(r => `<span class="reco-reason">${r}</span>`)
		      .join("");

		    const div = document.createElement("div");
		    div.className = "rated-item";

		    div.innerHTML = `
			  <div class="rated-title">
			    ${a.title}
			    ${isDiscovery ? `<span class="tag">D√©couverte</span>` : ""}
			    ${isSurprise ? `<span class="tag" style="background:#f97316;">Surprise</span>` : ""}
			    <div class="reco-reasons">
				  ${reasonsHtml}
			    </div>
			  </div>
			  <div class="rated-right">
			    <div class="rated-score">${a.avgRating?.toFixed(1) ?? "‚Äì"}</div>
			    <button class="rated-btn" onclick="window.location.href='anime.html?id=${a.id}'">
				  Voir
			    </button>
			  </div>
		    `;
		    recoListEl.appendChild(div);
		  });
		}

		// üîπ RECOMMANDATIONS ‚Äî Niveau 2 (pond√©ration intelligente)
		// IDs d√©j√† vus (not√©s + favoris)
		// üîπ MODES DE RECOMMANDATION (Niveau 9)
		const modeButtons = document.querySelectorAll(".reco-modes button");

		modeButtons.forEach(btn => {
		  btn.addEventListener("click", () => {

			// retirer active partout
			modeButtons.forEach(b => b.classList.remove("active"));

			// activer celui cliqu√©
			btn.classList.add("active");

			// changer le mode
			recoMode = btn.dataset.mode; // safe | smart | explore | community

			// recalculer les recos
			renderRecommendations();
		  });
		});
    
        // üîπ MES NOTES
        const ratedListEl = document.getElementById("ratedList");
        ratedListEl.innerHTML = "";
        if (ratedCount === 0) {
          ratedListEl.innerHTML = `<div style="opacity:.6; font-size:14px;">Aucune note pour l‚Äôinstant</div>`;
        } else {
          Object.entries(ratings).forEach(([animeId, userRating]) => {
            const anime = window.ANIMES?.find(a => a.id == animeId);
            if (!anime) return;

            const item = document.createElement("div");
            item.className = "rated-item";
            item.innerHTML = `
              <div class="rated-title">${anime.title}</div>
              <div class="rated-right">
                <div class="rated-score">${userRating}</div>
                <button class="rated-btn" data-id="${anime.id}">Voir</button>
              </div>
            `;

            item.querySelector(".rated-btn").addEventListener("click", () => {
			  window.location.href = `anime.html?id=${anime.id}`;
			});

            ratedListEl.appendChild(item);
			item.style.animationDelay = `${ratedListEl.children.length * 0.05}s`;
          });
        }

		// üîπ FAVORIS
		const favoritesListEl = document.getElementById("favoritesList");
		favoritesListEl.innerHTML = "";

		if (favorites.length === 0) {
		  favoritesListEl.innerHTML = `
			<div style="opacity:.6; font-size:14px;">
			  Aucun favori pour l‚Äôinstant
			</div>
		  `;
		} else {
		  favorites.forEach(animeId => {
			const anime = window.ANIMES?.find(a => a.id == animeId);
			if (!anime) return;

			const item = document.createElement("div");
			item.className = "rated-item";
			item.innerHTML = `
			  <div class="rated-title">${anime.title}</div>
			  <div class="rated-right">
				<div class="rated-score">‚ù§Ô∏è</div>
				<button class="rated-btn" data-id="${anime.id}">Voir</button>
			  </div>
			`;

			item.querySelector(".rated-btn").addEventListener("click", () => {
			  window.location.href = `anime.html?id=${anime.id}`;
			});

			favoritesListEl.appendChild(item);
			item.style.animationDelay = `${favoritesListEl.children.length * 0.05}s`;
		  });
		}
		if (window.ANIMES && Object.keys(ratings).length >= 0) {
		  renderRecommendations();
		}

      } catch (err) {
        console.error("Erreur profil :", err);
      }
    });

    document.getElementById("logoutBtn").addEventListener("click", async () => {
      await signOut(auth);
      window.location.href = "auth.html";
    });
  </script>
</body>
</html>