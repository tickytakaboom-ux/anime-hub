<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AnimeList</title>
  <style>
    :root {
	  --bg: #0f1724;
	  --card: #0b1220;
	  --muted: #9ca3af;
	  --accent: #06b6d4;
	  --glass: rgba(255,255,255,0.04);
	}

	/* üåå Global */
	body {
	  margin: 0;
	  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
	  background: linear-gradient(180deg,#0b1220 0%, #061226 100%);
	  color: #e6eef6;
	  -webkit-font-smoothing: antialiased;
	  -moz-osx-font-smoothing: grayscale;
	  transition: background 0.3s ease;
	}

	/* Container */
	.container {
	  max-width: 1100px;
	  margin: 32px auto;
	  padding: 20px;
	}
    
	/* Loader */
	.loader-overlay {
	  position: fixed;
	  inset: 0;
	  background: linear-gradient(180deg, rgba(11,18,32,0.98) 0%, rgba(6,18,38,0.98) 100%);
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  z-index: 2000;
	}
	.loader-card {
	  background: rgba(11,18,32,0.9);
	  border: 1px solid rgba(255,255,255,0.08);
	  border-radius: 18px;
	  padding: 24px 28px;
	  text-align: center;
	  box-shadow: 0 12px 30px rgba(0,0,0,0.45);
	  width: min(420px, 80vw);
	}
	.loader-spinner {
	  width: 44px;
	  height: 44px;
	  border-radius: 999px;
	  border: 3px solid rgba(255,255,255,0.12);
	  border-top-color: var(--accent);
	  animation: spin 0.9s linear infinite;
	  margin: 0 auto 14px;
	}
	.loader-text {
	  color: var(--muted);
	  font-size: 14px;
	  margin: 0;
	}
	@keyframes spin {
	  to { transform: rotate(360deg); }
	}
	
	/* Header sticky avec blur */
	header {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  gap: 16px;
	  margin-bottom: 18px;
	  position: sticky;
	  top: 0;
	  z-index: 100;
	  background: linear-gradient(180deg, rgba(11,18,32,0.95) 0%, rgba(6,18,38,0.95) 100%);
	  backdrop-filter: blur(8px);
	  padding: 20px 40px;
	  flex-wrap: wrap;
	  transition: box-shadow 0.2s ease, background 0.2s ease;
	}
	header.sticky { box-shadow: 0 6px 20px rgba(0,0,0,0.6); }
	
	.logo-container {
	  display: flex;
	  flex-direction: column;
	  gap: 2px;
	}
	
	h1 { font-size: 28px; margin: 0; }
	p.lead { color: var(--muted); margin: 6px 0 0; font-size: 14px; }

	/* Controls recherche / filtres */
	.controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
	.search-wrap { position: relative; }
	.search-wrap svg { position: absolute; left: 10px; top: 50%; transform: translateY(-50%); opacity: 0.8; }
	input.search {
	  padding: 10px 12px 10px 36px;
	  border-radius: 10px;
	  border: 1px solid rgba(255,255,255,0.06);
	  background: var(--glass);
	  color: inherit;
	  min-width: 220px;
	  transition: 0.3s;
	  box-shadow: 0 0 4px rgba(255,255,255,0.1);
	}
	input.search:focus { border-color: var(--accent); box-shadow: 0 0 12px rgba(6,182,212,0.3); outline: none; }
	.select, .select-sm {
	  padding: 10px 12px;
	  border-radius: 10px;
	  background: var(--glass);
	  border: 1px solid rgba(255,255,255,0.06);
	  color: inherit;
	  transition: 0.3s;
	  box-shadow: 0 0 4px rgba(255,255,255,0.1);
	}
	.select:hover, .select-sm:hover { border-color: var(--accent); box-shadow: 0 0 10px rgba(6,182,212,0.25); }
	.select option, .select-sm option { color: #e6eef6; background-color: var(--card); }
	@media (max-width:720px) {
		.controls > select, input.search { flex: 1 1 100%; }
	}
	/* Grid cartes anime */
	.grid {
	  display: grid;
	  grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
	  gap: 16px;
	  margin-top: 18px;
	}

	/* Cartes anime avec hover n√©on */
	.card {
	  background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.06));
	  border-radius: 14px;
	  overflow: hidden;
	  box-shadow: 0 6px 18px rgba(6,182,212,0.4);
	  transition: transform 0.2s ease, box-shadow 0.2s ease;
	  position: relative;
	}
	.card:hover {
	  transform: translateY(-4px) rotateZ(-0.2deg);
	  box-shadow: 0 12px 30px rgba(6,182,212,0.6), 0 0 20px rgba(6,182,212,0.25);
	}
	.card img { width: 100%; aspect-ratio: 2/3; object-fit: cover; display: block; background: #111; transition: 0.3s; }
	.card:hover img { filter: brightness(1.1); }

	/* Card content */
	.card-body { padding: 14px; }
	.title { font-weight: 700; font-size: 16px; margin: 8px 0 6px; transition: color 0.3s; }
	.card:hover .title { color: var(--accent); }
	.genres { font-size: 12px; color: var(--muted); }
	.meta { display: flex; justify-content: space-between; align-items: center; gap: 8px; color: var(--muted); font-size: 13px; }

	/* Boutons */
	.btn {
	  background: linear-gradient(135deg, var(--accent), #0fc1e5);
	  color: #052226;
	  padding: 8px 14px;
	  border-radius: 10px;
	  border: none;
	  cursor: pointer;
	  font-weight: 700;
	  font-size: 13px;
	  letter-spacing: 0.3px;
	  box-shadow: 0 4px 14px rgba(6,182,212,0.35);
	  transition: transform 0.15s ease, box-shadow 0.15s ease, filter 0.15s ease;
	}
	.btn:hover { transform: translateY(-2px); box-shadow: 0 8px 22px rgba(6,182,212,0.55); filter: brightness(1.05); }
	.btn:active { transform: translateY(0); box-shadow: 0 4px 12px rgba(6,182,212,0.35); }

	/* Favoris / rating */
	.fav-btn {
	  background: transparent;
	  border: 1px solid rgba(255,255,255,0.06);
	  color: var(--accent);
	  padding: 6px 8px;
	  border-radius: 8px;
	  cursor: pointer;
	  font-weight: 700;
	  font-size: 14px;
	  transition: 0.2s;
	}
	.fav-btn:hover { background: rgba(255,255,255,0.08); backdrop-filter: blur(4px) }

	/* Rating badges */
	.rating { background: rgba(0,0,0,0.45); padding: 4px 8px; border-radius: 12px; font-weight: 700; font-size: 13px; }

	/* Footer */
	footer { text-align: center; color: var(--muted); margin-top: 24px; font-size: 13px; }

	/* Scroll animations */
	@keyframes fadeUp {
	  0% { opacity: 0; transform: translateY(20px); }
	  100% { opacity: 1; transform: translateY(0); }
	}

	/* Responsive */
	@media (max-width:720px) {
	  header { flex-direction: column; align-items: center; text-align: center; }
	  .logo-container { width: 100%; align-items: center; }
	  .controls { width: 100%; margin-top: 10px; flex-wrap: wrap; justify-content: center; }
	  .card img { height: 220px; }
	  .modal { flex-direction: column; align-items: center; }
	  .modal img { width: 180px; height: 260px; }
	}
	
	.fallback-img {
	  object-fit: contain;
	  background: #0b1220;
	}
	
	/* Bouton Top */
	#backToTop {
	  position: fixed; bottom: 22px; right: 22px; padding: 10px 14px;
	  font-size: 16px; border-radius: 10px; background: var(--accent);
	  color: #052226; border: none; cursor: pointer; font-weight: 700;
	  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
	  transition: opacity .2s ease, transform .2s ease;
	  display: none;
	}
	#backToTop.show { display: inline-flex; align-items: center; justify-content: center; opacity: 1; transform: translateY(0); }
	#backToTop.hide { 
	  opacity: 0; 
	  transform: 
	  translateY(10px); 
	}
	
	.badge-trending {
	  position: absolute;
	  top: 10px;
	  left: 10px;
	  background: #ff4500;
	  color: white;
	  font-size: 11px;
	  padding: 2px 6px;
	  border-radius: 6px;
	  font-weight: bold;
	  z-index: 10; /* s'assure qu'il soit au-dessus de l'image */
	  pointer-events: none; /* pas cliquable */
	}
	.card { position: relative; } /* n√©cessaire pour que le badge soit bien positionn√© par rapport √† la carte */
	
	#authContainer {
	  display: flex;
	  gap: 8px;
	  align-items: center;
	  background: rgba(11,18,32,0.85);
	  padding: 6px 12px;
	  border-radius: 12px;
	  backdrop-filter: blur(6px);
	  flex-wrap: wrap;
	  position: relative;
	  z-index: 999;
	  margin-left: 300px;
	}

	#userBox {
	  display: flex;
	  align-items: center;
	  gap: 6px;
	  background: rgba(255,255,255,0.12);
	  padding: 6px 14px;
	  border-radius: 999px;
	  color: white;
	  font-weight: 700;
	  text-decoration: none;
	  cursor: pointer;
	  transition: background 0.2s;
	  z-index: 100;
	}
	#userBox:hover { background: rgba(255,255,255,0.2); }

	.notif-container { 
	  position: relative;
	  border-radius: 10px;
	  padding: 8px;
	  cursor: pointer;
	}
	.notif-container:hover {
	  background: rgba(255,255,255,0.12);
	}
	.notif-badge {
	  position: absolute;
	  top: -4px;
	  right: -6px;

	  min-width: 16px;
	  height: 16px;
	  padding: 0 4px;

	  display: none;
	  align-items: center;
	  justify-content: center;

	  background: #ef4444; /* rouge clean */
	  color: white;

	  font-size: 10px;
	  font-weight: 800;
	  line-height: 1;

	  border-radius: 999px;
	  border: 2px solid #0b1220; /* fond du header */

	  box-shadow: 0 2px 6px rgba(0,0,0,0.6);
	  z-index: 200;
	}
	/* DESKTOP */
	.notif-dropdown {
	  position: absolute;
	  top: calc(100% + 10px);
	  right: 0;
	  width: min(360px, calc(100vw - 24px));
	  max-height: 70vh;
	  overflow: hidden;
	  background: #0f172a;
	  border-radius: 14px;
	  border: 1px solid rgba(255,255,255,0.08);
	  box-shadow: 0 15px 40px rgba(0,0,0,0.6);
	  z-index: 1000;
	}
	
	.notif-header {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  gap: 10px;
	  padding: 10px 12px;
	  border-bottom: 1px solid rgba(255,255,255,0.08);
	}
	.notif-title {
	  margin: 0;
	  font-size: 14px;
	  font-weight: 700;
	}
	.notif-actions {
	  display: flex;
	  gap: 8px;
	}
	.notif-action-btn {
	  border: 1px solid rgba(255,255,255,0.15);
	  background: rgba(255,255,255,0.05);
	  color: #e6eef6;
	  border-radius: 8px;
	  padding: 4px 8px;
	  font-size: 12px;
	  cursor: pointer;
	}
	.notif-action-btn:hover {
	  background: rgba(255,255,255,0.12);
	}
	#notifList {
	  list-style: none;
	  margin: 0;
	  padding: 0;
	  max-height: min(52vh, 420px);
	  overflow-y: auto;
	}
	
	/* MOBILE = bottom sheet */
	@media (max-width: 768px) {
	  .notif-dropdown {
		position: fixed;
		bottom: 0;
		left: 0;
		right: 0;

		width: 100vw;
		height: 70vh;

		border-radius: 18px 18px 0 0;
		animation: slideUp 0.25s ease;
	  }
	  #notifList {
		max-height: calc(70vh - 54px);
		padding-bottom: max(8px, env(safe-area-inset-bottom));
	  }
	}
	@keyframes slideUp {
	  from {
		transform: translateY(100%);
	  }
	  to {
		transform: translateY(0);
	  }
	}
	
	#notifList li {
	  padding: 12px 14px;
	  font-size: 14px;
	  border-bottom: 1px solid rgba(255,255,255,0.08);
	  color: #e6eef6;
	  word-break: break-word;
	  white-space: normal;
	  line-height: 1.35;
	}
	#notifList li.unread {
	  background: rgba(6,182,212,0.08);
	  border-left: 3px solid var(--accent);
	}

	#notifList li:last-child {
	  border-bottom: none;
	}

	#notifList li:hover {
	  background: rgba(255,255,255,0.05);
	}
	#notifEmpty {
	  padding: 16px;
	  color: var(--muted);
	  text-align: center;
	  font-size: 13px;
	}
	.notif-badge.show {
	  display: flex;
	  animation: pop 0.25s ease;
	}

	@keyframes pop {
	  0% { transform: scale(0); }
	  80% { transform: scale(1.2); }
	  100% { transform: scale(1); }
	}
	@media (max-width:720px) {
		header { padding: 16px 20px; }
	}
	*, *::before, *::after {
		transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
	}
	.logo {
	  font-family: 'Mochiy Pop One', sans-serif;
	  font-size: 2.2rem;
	  background: linear-gradient(
		90deg,
		#fff59d,
		#ffeb3b,
		#ff9800,
		#ff5722
	  );
	  -webkit-background-clip: text;
	  -webkit-text-fill-color: transparent;
	}
    @font-face {
      font-family: 'Mochiy Pop One';
      src: url('MochiyPopOne-Regular.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
	.logo-sub {
	  font-size: 0.75rem;
	  color: #cbd5e1;
	  margin-top: 4px;
	  letter-spacing: 0.3px;
	}
    @media (max-width: 600px) {
	  .logo {
		font-size: 1.6rem;
	  }
	  .logo-sub {
		font-size: 0.65rem;
	  }
	}
	body {
      opacity: 1;
      transition: opacity 0.6s ease;
    }

    body.fonts-not-loaded {
      opacity: 0;
    }
	.btn:focus-visible,
	.fav-btn:focus-visible,
	#backToTop:focus-visible {
	  outline: 2px solid rgba(6,182,212,0.8);
	  outline-offset: 2px;
	}
  </style>
  <!-- Favicon classique -->
  <link rel="icon" type="image/png" href="icon_animehub.png">
  <!-- Ic√¥ne Apple touch (pour iPhone/iPad) -->
  <link rel="apple-touch-icon" sizes="180x180" href="icon_animehub.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icon_animehub.png">
  <link rel="apple-touch-icon" sizes="120x120" href="icon_animehub.png">
  <link rel="apple-touch-icon" sizes="76x76" href="icon_animehub.png">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>
</head>
<body class="fonts-not-loaded">
	<div class="loader-overlay" id="pageLoader" aria-live="polite" aria-busy="true">
	  <div class="loader-card">
		<div class="loader-spinner" aria-hidden="true"></div>
		<p class="loader-text" id="loadingMessage">Chargement...</p>
	  </div>
	</div>
    <header>
      <div class="logo-container" id="homeLogo" style="cursor:pointer;">
	    <h1 class="logo">AnimeHub</h1>
	    <p class="lead">Ton univers anime √† port√©e de clic</p>
	  </div>

      <div class="controls">
        <div class="search-wrap">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden><path d="M21 21l-4.35-4.35" stroke="#9ca3af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><circle cx="11" cy="11" r="6" stroke="#9ca3af" stroke-width="2"></circle></svg>
          <input id="search" class="search" placeholder="Rechercher un anime..."/>
        </div>
        <select id="genre" class="select"></select>
        <select id="sort" class="select-sm">
          <option value="top">Top rating</option>
          <option value="new">Les plus r√©cents</option>
		  <option value="az">Alphab√©tique (A ‚Üí Z)</option>
		  <option value="za">Alphab√©tique (Z ‚Üí A)</option>
		  <option value="popular">üî• Popularit√©</option>
        </select>
		<select id="statusFilter" class="select-sm">
          <option value="all">Tous statuts</option>
          <option value="completed">‚úÖ D√©j√† vu</option>
          <option value="watching">‚ñ∂Ô∏è En cours</option>
          <option value="planned">üïí √Ä voir</option>
        </select>
        <select id="favFilter" class="select-sm">
          <option value="all">Tous</option>
          <option value="fav">Favoris seulement</option>
        </select>
      </div>
	  <div id="authContainer">
	    <div class="notif-container" id="notifBtn">
		  <i class="fa-solid fa-bell"></i>
		  <span class="notif-badge" id="notifBadge">0</span>

		  <div class="notif-dropdown" id="notifDropdown" style="display:none;">
			<div class="notif-header">
			  <p class="notif-title">Notifications</p>
			  <div class="notif-actions">
				<button class="notif-action-btn" id="notifMarkAllBtn" type="button">Tout lire</button>
				<button class="notif-action-btn" id="notifCloseBtn" type="button">Fermer</button>
			  </div>
			</div>
			<ul id="notifList"></ul>
			<div id="notifEmpty" style="display:none;">Aucune notification pour le moment.</div>
		  </div>
		</div>
		<a href="profile.html" id="userBox">
          <span id="username"></span>
        </a>
	  </div>
	  <div id="authModal" class="modal-auth" style="display:none;">
	    <div class="modal-auth-content">
		  <h2 id="authTitle">Connexion</h2>

		  <input type="email" id="authEmail" placeholder="Email">
		  <input type="password" id="authPassword" placeholder="Mot de passe">

		  <button id="authSubmit">Valider</button>
		  <button id="authClose" class="close-auth">Fermer</button>
	    </div>
	  </div>
    </header>
	<div class="container">
    <main>
      <div id="grid" class="grid" style="display:none"></div>
	   <div id="loading" style="display:none;"></div>
      <div id="empty" style="display:none; color:var(--muted); text-align:center; padding:40px 0;">Aucun r√©sultat...</div>
    </main>

    <footer>Il manque ton anime ? N'h√©site pas √† demander pour que je le rajoute.</footer>
  </div>

  <!-- Modal template -->
  <div id="modalRoot" style="display:none"></div>
  <button id="backToTop">‚Üë Top</button>
  <script>
    let ANIMES = [];

	const genreEl = document.getElementById('genre');
	const sortEl = document.getElementById('sort');
	const favFilterEl = document.getElementById('favFilter');
	const statusFilterEl = document.getElementById('statusFilter');
	const grid = document.getElementById('grid');
	const searchInput = document.getElementById('search');
	const empty = document.getElementById('empty');
	const modalRoot = document.getElementById('modalRoot');
	const urlParams = new URLSearchParams(window.location.search);
	const favFromUrl = urlParams.get("fav"); // "1" ou null
	let genreFromUrl = urlParams.get('genre'); // ex: "Action" ou null
	const loadingMessages = [
	  "‚è≥ Kira observe‚Ä¶ chargement des animes en cours",
	  "üìì Le Death Note s‚Äôouvre‚Ä¶ pr√©paration de l‚Äôunivers",
	  "üëÅÔ∏è Ryuk rigole pendant que les animes arrivent",
	  "‚öñÔ∏è La justice prend forme‚Ä¶ chargement des donn√©es",
	  "üß± Les murs tremblent‚Ä¶ les animes arrivent",
	  "‚öîÔ∏è Le Bataillon d‚ÄôExploration pr√©pare la page",
	  "üëÅÔ∏è Eren regarde l‚Äôhorizon‚Ä¶ chargement en cours",
	  "ü©∏ La libert√© a un prix‚Ä¶ donn√©es en cours de d√©ploiement",
	  "üü† Chargement en cours‚Ä¶ le ki monte",
	  "üåå Voyage vers Namek‚Ä¶ encore un instant",
	  "üêâ Shenron est invoqu√©‚Ä¶ pr√©paration des animes",
	  "ü©∏ La mort n‚Äôest pas la fin‚Ä¶ chargement",
	  "üïØÔ∏è Echidna observe‚Ä¶ patience",
	];

	const loadingEl = document.getElementById("loading");
	const pageLoader = document.getElementById("pageLoader");
	const loadingMessage = document.getElementById("loadingMessage");

	if (loadingEl) {
	  const randomMessage =
		loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
	  loadingEl.textContent = randomMessage;
	  if (loadingMessage) {
		loadingMessage.textContent = randomMessage;
	  }
	}
	function refreshGenres() {
		  const genres = new Set(["Tout"]);
		  ANIMES.forEach(a => (a.genre || []).forEach(g => genres.add(g)));
		  genreEl.innerHTML = "";
		  genres.forEach(g => {
			const o = document.createElement("option");
			o.textContent = o.value = g;
			genreEl.appendChild(o);
		  });

	  if (genreFromUrl) {
			const exists = [...genreEl.options].some(
			  opt => opt.value === genreFromUrl
			);

			if (exists) {
			  genreEl.value = genreFromUrl;
			}
		  }
		}
	
		const ITEMS_PER_LOAD = 6; // combien de cartes √† charger √† chaque fois
	let currentIndex = 0; // index de d√©part pour le rendu
	let filteredList = []; // liste filtr√©e apr√®s recherche/tri

	function openAnime(id) {
	  window.location.href = `anime.html?id=${id}`;
	}
	function renderList(list){
	  grid.innerHTML = '';
	  if(!list.length){ empty.style.display='block'; return; }
	  empty.style.display='none';

	  list.forEach((a, index) => {
			  const poster = a.img || "icon_animehub.png";
			  const ratingDisplay = Number.isFinite(a.rating)
				? a.rating.toFixed(1)
				: "N/A";
			  const card = document.createElement('div'); 
			  card.className = 'card';
			  card.style.animationDelay = `${index * 0.08}s`; // 0.08s entre chaque carte
			  card.innerHTML = `
				<img src="${poster}" alt="${a.title || "Anime"}" class="${a.img ? "" : "fallback-img"}">
				<div class="card-body">
				  <div class="meta"><div class="genres">${(a.genre || []).join(' ‚Ä¢ ')}</div><div class="rating">${ratingDisplay}</div></div>
				  <div class="title">${a.title}</div>
				  <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
					<div style="color:var(--muted); font-size:13px">${a.year ?? "‚Äî"}</div>
				<div style="display:flex; gap:6px;">
				  <button class="fav-btn" data-id="${a.id}">${a.fav?'‚òÖ':'‚òÜ'}</button>
				  <button class="btn" onclick="openAnime(${a.id})">Voir</button>
				</div>
			  </div>
			</div>`;
		  grid.appendChild(card);
		});
	  // Modale et favoris
	  grid.querySelectorAll('.fav-btn').forEach(b => b.addEventListener('click', e=>{
		e.stopPropagation(); toggleFavorite(Number(b.dataset.id));
	  }));
	}
	function renderNextBatch() {
	  const grid = document.getElementById('grid');
	  if (currentIndex >= filteredList.length) return;

	  const nextBatch = filteredList.slice(currentIndex, currentIndex + ITEMS_PER_LOAD);
	  nextBatch.forEach((a, index) => {
			const poster = a.img || "icon_animehub.png";
			const ratingDisplay = Number.isFinite(a.rating)
			  ? a.rating.toFixed(1)
			  : "N/A";
			const card = document.createElement('div');
			card.className = 'card';
			card.style.animationDelay = `${(currentIndex + index) * 0.08}s`;

			card.innerHTML = `
			  <img src="${poster}" alt="${a.title || "Anime"}" class="${a.img ? "" : "fallback-img"}">
			  <div class="card-body">
				<div class="meta">
				  <div class="genres">${(a.genre || []).join(' ‚Ä¢ ')}</div>
				  <div class="rating">${ratingDisplay}</div>
				</div>
			<div id="activeGenre" class="active-genre hidden"></div>
			<div class="title">
			  ${a.title}
			  ${a.likes >= 3 ? `<span class="badge-trending">üî• Tendance</span>` : ''}
			</div>

			<div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
			  <div style="color:var(--muted); font-size:13px">${a.year ?? "‚Äî"}</div>

			  <div style="display:flex; gap:6px; align-items:center;">
				<button class="fav-btn" data-id="${a.id}">${a.fav ? '‚òÖ' : '‚òÜ'}</button>
				<button class="btn" onclick="openAnime(${a.id})">Voir</button>
			  </div>
			</div>
		  </div>
		`;

		grid.appendChild(card);
	  });

	  currentIndex += ITEMS_PER_LOAD;
	  
	  // Afficher message si plus de r√©sultats
	  empty.style.display = currentIndex >= filteredList.length && filteredList.length === 0 ? 'block' : 'none';
	}
	function openModal(a){
	  modalRoot.innerHTML = `
		<div class="modal-backdrop" id="backdrop">
		  <div class="modal">
			<img src="${a.img}" alt="${a.title}">
			<div class="info">
			  <h2 style="margin:0 0 6px">${a.title}</h2>
			  <div style="color:var(--muted); margin-bottom:10px">
				${a.genre.join(' ‚Ä¢ ')} ‚Ä¢ ${a.year}
			  </div>
			  <p style="margin:0 0 12px; line-height:1.5; color:#dbeafe;">
				${a.summary}
			  </p>
			  <div style="display:flex; gap:8px; align-items:center">
				<div class="rating">${a.rating.toFixed(1)}</div>
				<button class="close" id="closeModal">Fermer</button>
			  </div>
			</div>
		  </div>
		</div>
	  `;

	  modalRoot.style.display = 'block';

	  document.getElementById('closeModal').onclick = closeModal;
	  document.getElementById('backdrop').onclick = (e) => {
		if (e.target.id === 'backdrop') closeModal();
	  };
	}

	function closeModal(){
	  modalRoot.style.display = 'none';
	  modalRoot.innerHTML = '';
	}
	// üîπ ouverture modale via URL (?anime=ID)
	const params = new URLSearchParams(window.location.search);
	const animeId = params.get("anime");

	if (animeId) {
	  const anime = ANIMES.find(a => a.id == animeId);
	  if (anime && typeof openModal === "function") {
		openModal(anime);

		// optionnel : nettoyer l'URL
		window.history.replaceState({}, "", "index.html");
	  }
	}
	function applyFilters() {
	  const q = searchInput.value.toLowerCase();
	  const g = genreEl.value;
	  const s = sortEl.value;
	  const f = favFilterEl.value;

	  filteredList = ANIMES.filter(a =>
		(a.title || "").toLowerCase().includes(q)
	  );

	  // üîπ FILTRE GENRE (select)
	  if (g !== 'Tout') {
		filteredList = filteredList.filter(a => (a.genre || []).includes(g));
	  }

	  // üî• FILTRE GENRE (URL) ‚Äî AJOUT ICI
	  if (genreFromUrl) {
		filteredList = filteredList.filter(a =>
		  (a.genre || []).includes(genreFromUrl)
		);
	  }

	  // üîπ FAVORIS
	  if (f === 'fav') {
		filteredList = filteredList.filter(a => a.fav);
	  }
	  if (favFromUrl === "1") {
	    favFilterEl.value = "fav";
	  }
	  
	  // üîπ STATUT DE VISIONNAGE
	  if (statusFilterEl.value !== 'all') {
		filteredList = filteredList.filter(
		  a => a.status === statusFilterEl.value
		);
	  }

	  // üîπ TRI
	  if (s === 'top') {
		filteredList.sort((a, b) => {
		  const ratingA = Number.isFinite(a.rating) ? a.rating : -1;
		  const ratingB = Number.isFinite(b.rating) ? b.rating : -1;
		  return ratingB - ratingA;
		});
	  }
	  if (s === 'new') filteredList.sort((a, b) => (b.year || 0) - (a.year || 0));
	  if (s === 'az') filteredList.sort((a, b) => a.title.localeCompare(b.title));
	  if (s === 'za') filteredList.sort((a, b) => b.title.localeCompare(a.title));
	  if (s === 'popular') {
		filteredList.sort((a, b) => (b.likes || 0) - (a.likes || 0));
	  }

	  // üîπ RESET AFFICHAGE
	  currentIndex = 0;
	  grid.innerHTML = '';
	  renderNextBatch();
	}
	searchInput.addEventListener('input', applyFilters);
	genreEl.addEventListener('change', () => {
	  const selected = genreEl.value;

	  if (selected === 'Tout') {
		genreFromUrl = null;
		urlParams.delete('genre');
	  } else {
		genreFromUrl = selected;
		urlParams.set('genre', selected);
	  }

	  const newUrl =
		window.location.pathname +
		(urlParams.toString() ? '?' + urlParams.toString() : '');

	  window.history.replaceState({}, '', newUrl);

	  applyFilters();
	});
	sortEl.addEventListener('change', applyFilters);
	favFilterEl.addEventListener('change', applyFilters);
	statusFilterEl.addEventListener('change', applyFilters);
	
	const backToTop = document.getElementById('backToTop');
	backToTop.classList.add('hide');
	backToTop.addEventListener('click', () => {
	  window.scrollTo({ top: 0, behavior: 'smooth' });
	});
	window.AnimeHub = { ANIMES, renderList, applyFilters };
	window.addEventListener('scroll', () => {
	  if (window.scrollY > 50) {
		backToTop.classList.add('show');
		backToTop.classList.remove('hide');
	  } else {
		backToTop.classList.add('hide');
		setTimeout(() => backToTop.classList.remove('show'), 200);
	  }
	
	  if(window.scrollY > 20){
		document.querySelector('header').classList.add('sticky');
	  } else {
		document.querySelector('header').classList.remove('sticky');
	  }

	  // Infinite scroll
	  if(window.innerHeight + window.scrollY >= document.body.offsetHeight - 200) {
		renderNextBatch();
	  }
	});
	const authModal = document.getElementById("authModal");
	const authTitle = document.getElementById("authTitle");
	const authSubmit = document.getElementById("authSubmit");
	const authEmail = document.getElementById("authEmail");
	const authPassword = document.getElementById("authPassword");

	document.getElementById("authClose").onclick = () => {
	  authModal.style.display = "none";
	};
	document.fonts.ready.then(() => {
      document.body.classList.remove("fonts-not-loaded");
    });
	// Les filtres sont appliqu√©s apr√®s chargement Firestore dans onAuthStateChanged.
	document.getElementById("homeLogo").addEventListener("click", () => {
	  window.location.href = "index.html";
	});
  </script>
  <script type="module">
      import { 
          initializeApp 
      } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
      import {
	      getAuth, onAuthStateChanged
	  } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
	  import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove, increment, collection, getDocs, query, where, orderBy, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";
	  
      const firebaseConfig = {
          apiKey: "AIzaSyCaJZi1Bn1vbeKOC5cM3Gi6nOFyWaH4NK4",
          authDomain: "animehub-7.firebaseapp.com",
          projectId: "animehub-7",
          storageBucket: "animehub-7.firebasestorage.app",
          messagingSenderId: "159114039206",
          appId: "1:159114039206:web:0461d676e7ffff25c4c967",
          measurementId: "G-6K4MB0XQEV"
      };

      const app = initializeApp(firebaseConfig);
      const userBox = document.getElementById("userBox");
      const username = document.getElementById("username");

      const openLogin = document.getElementById("openLogin");
      const openSignup = document.getElementById("openSignup");
	  const db = getFirestore(app);
	  const auth = getAuth(app);
	  const grid = document.getElementById("grid"); // ou le bon id
	  const notifBadge = document.getElementById("notifBadge");
	  const notifDropdown = document.getElementById("notifDropdown");
	  const notifList = document.getElementById("notifList");
	  const notifEmpty = document.getElementById("notifEmpty");
	  const notifMarkAllBtn = document.getElementById("notifMarkAllBtn");
	  const notifCloseBtn = document.getElementById("notifCloseBtn");
	  const urlParams = new URLSearchParams(window.location.search);
	  const notifBtn = document.getElementById("notifBtn");
	  let notifItems = [];

	  function setNotifDropdownOpen(isOpen) {
		notifDropdown.style.display = isOpen ? "block" : "none";
	  }
	  
	  notifBtn.addEventListener("click", (event) => {
		event.stopPropagation();
		setNotifDropdownOpen(notifDropdown.style.display === "none");
	  });
	  notifDropdown.addEventListener("click", (event) => {
		event.stopPropagation();
	  });
	  notifCloseBtn.addEventListener("click", () => {
		setNotifDropdownOpen(false);
	  });
	  notifMarkAllBtn.addEventListener("click", async (event) => {
		event.stopPropagation();
		const unreadItems = notifItems.filter((item) => !item.read);
		if (!unreadItems.length) return;
		await Promise.all(
		  unreadItems.map((item) => updateDoc(doc(db, "notifications", item.id), { read: true }))
		);
		notifItems = notifItems.map((item) => ({ ...item, read: true }));
		renderNotifications();
	  });
	  document.addEventListener("click", (event) => {
		if (!notifBtn.contains(event.target)) {
		  setNotifDropdownOpen(false);
		}
	  });
	  document.addEventListener("keydown", (event) => {
		if (event.key === "Escape") {
		  setNotifDropdownOpen(false);
		}
	  });
	  userBox.addEventListener("click", () => {
        window.location.href = "profile.html";
      });

	  onAuthStateChanged(auth, async (user) => {
	    if (user) {
		  if (openLogin) openLogin.style.display = "none";
		  if (openSignup) openSignup.style.display = "none";
		  userBox.style.display = "flex";
		  await loadAnimes();
		  await loadFavorites();
		  await loadStatuses();
		  await loadNotifications(user.uid);;
		  applyFilters();
		  try {
		    const userDocRef = doc(db, "users", user.uid);
		    const userSnap = await getDoc(userDocRef);

		    if (userSnap.exists()) {
		      const data = userSnap.data();
			  username.textContent = data.username || user.email.split("@")[0];
		    } else {
			  // Cr√©e le doc Firestore si inexistant (utile pour comptes cr√©√©s avant Firestore)
			  const userData = {
			    username: user.email.split("@")[0],
			    email: user.email,
			    favorites: [],
			    ratings: {}
			  };
			  await setDoc(userDocRef, userData);
			  username.textContent = userData.username;
		    }

		  } catch (err) {
		    console.error("Erreur r√©cup√©ration Firestore:", err);
		    username.textContent = user.email.split("@")[0]; // fallback
		  }

	    } else {
		  if (openLogin) openLogin.style.display = "inline-block";
		  if (openSignup) openSignup.style.display = "inline-block";
		  userBox.style.display = "none";
		  if (pageLoader) {
			pageLoader.style.display = "none";
			pageLoader.setAttribute("aria-busy", "false");
		  }
	    }
	  });
	  async function sendNotification(userId, title, message = "") {
	    try {
		  await addDoc(collection(db, "notifications"), {
		    userId: userId,
		    title: title,
		    message: message,
		    read: false,
		    createdAt: serverTimestamp()
		  });
		  await loadNotifications(userId);
	    } catch (err) {
		  console.error("Erreur notification:", err);
	    }
	  }

	  async function toggleFavorite(animeId) {
	    const user = auth.currentUser;
	    if (!user) {
		  alert("Connecte-toi pour ajouter un favori !");
		  return;
	   }

	    const anime = ANIMES.find(a => a.id === animeId);
	    if (!anime) return;

	    const userRef = doc(db, "users", user.uid);
	    const animeRef = doc(db, "animes", String(animeId));

	    const wasFav = anime.fav;
	    anime.fav = !wasFav;

	    try {
		  // üîπ S'assurer que le doc anime existe
		  const snap = await getDoc(animeRef);
		  if (!snap.exists()) {
		    await setDoc(animeRef, { likes: 0 }, { merge: true });
		  }

		  // üîπ Mettre √† jour les favoris de l'utilisateur
		  if (!wasFav) {
		    await updateDoc(userRef, { favorites: arrayUnion(animeId) });
		    await updateDoc(animeRef, { likes: increment(1) });
			await sendNotification(user.uid, `Tu as ajout√© ${anime.title} √† tes favoris !`);
		  } else {
		    await updateDoc(userRef, { favorites: arrayRemove(animeId) });
		    await updateDoc(animeRef, { likes: increment(-1) });
		  }
	    } catch (err) {
		  console.error("Erreur toggleFavorite:", err);
	    }
		if (anime.likes === 3) {
		  sendNotificationToAllUsers(
			"üî• Anime tendance",
			anime.title
		  );
		}

	    // üîπ Mettre √† jour l'UI
	    const btn = document.querySelector(`.fav-btn[data-id="${animeId}"]`);
	    if (btn) btn.textContent = anime.fav ? "‚òÖ" : "‚òÜ";
		
		applyFilters();
	  }
	  window.toggleFavorite = toggleFavorite;

	  // Favoris
	  grid.addEventListener('click', e => {
	   if (e.target.classList.contains('fav-btn')) {
		  e.stopPropagation();
		  const id = Number(e.target.dataset.id);
		  toggleFavorite(id);
	    }
	  });
	  async function loadFavorites() {
	    const user = auth.currentUser;
	    if (!user) return;

	    const userRef = doc(db, "users", user.uid);
	    const snap = await getDoc(userRef);

	    if (!snap.exists()) return;

	    const data = snap.data();
	    if (!Array.isArray(data.favorites)) return;

	    // üî• Synchronisation Firestore ‚Üí UI
	    ANIMES.forEach(anime => {
		  anime.fav = data.favorites.includes(anime.id);
	    });
	  }
	  
	  async function loadStatuses() {
	    const user = auth.currentUser;
	    if (!user) return;

	    const userRef = doc(db, "users", user.uid);
	    const snap = await getDoc(userRef);
	    if (!snap.exists()) return;

	    const data = snap.data();
	    const statuses = data.statuses || {};
	    ANIMES.forEach(anime => {
		  anime.status = statuses[anime.id] || null;
	    });
	  }
	  
	  async function loadNotifications(userId) {
	    const notifCol = collection(db, "notifications");
	    const q = query(notifCol, where("userId", "==", userId), orderBy("createdAt", "desc"));
	    const snapshot = await getDocs(q);
	    notifItems = snapshot.docs.map((docSnap) => ({
		  id: docSnap.id,
		  ...docSnap.data()
		}));
		renderNotifications();
	  }

	  function renderNotifications() {
		notifList.innerHTML = "";
		let unreadCount = 0;

		if (!notifItems.length) {
		  notifEmpty.style.display = "block";
		} else {
		  notifEmpty.style.display = "none";
		}

		notifItems.forEach((notif) => {
		  const li = document.createElement("li");
		  li.className = notif.read ? "" : "unread";
		  li.innerHTML = `
		    <strong>${notif.title}</strong><br>
			<span style="font-size: 0.85em; opacity: 0.8;">${notif.message || ""}</span>
		  `;

		  if (!notif.read) unreadCount++;

		  li.addEventListener("click", async (event) => {
			event.stopPropagation();
			if (notif.read) return;
			await updateDoc(doc(db, "notifications", notif.id), { read: true });
			notif.read = true;
			li.classList.remove("unread");
			renderNotifications();
		  });
		
		  notifList.appendChild(li);
	    });
	  
	    notifBadge.textContent = unreadCount;
	    if(unreadCount > 0) notifBadge.classList.add("show");
	    else notifBadge.classList.remove("show");
	  }
	async function sendNotificationToAllUsers(title, message = "") {
	  console.warn("sendNotificationToAllUsers est d√©sactiv√© c√¥t√© client. √Ä d√©placer c√¥t√© backend (Cloud Function).", { title, message });
	  return;

	  /*
	    if (!title) {
		  console.warn("‚ùå Notification annul√©e : title manquant");
		  return;
	    }

	    const usersSnap = await getDocs(collection(db, "users"));
	    const promises = [];

	    usersSnap.forEach(userDoc => {
		  promises.push(
		    addDoc(collection(db, "notifications"), {
			  userId: userDoc.id,
			  title: title,
			  message: message,
			  read: false,
			  createdAt: serverTimestamp()
		    })
		  );
	    });

	    await Promise.all(promises);
	    console.log("‚úÖ Notification envoy√©e √† tous les utilisateurs");
	  */
	  }

	  async function sendSiteUpdateNotification(version, message) {
	    console.warn("sendSiteUpdateNotification est d√©sactiv√© c√¥t√© client. √Ä d√©placer c√¥t√© backend (Cloud Function).", { version, message });
	    return;

	    /*
	    const metaRef = doc(db, "meta", "lastSiteUpdate");
	    const snap = await getDoc(metaRef);
 
	    // Emp√™che d'envoyer 2 fois la m√™me mise √† jour
	    if (snap.exists() && snap.data().version === version) return;

	    const usersSnap = await getDocs(collection(db, "users"));

	    const promises = [];
	    usersSnap.forEach(userDoc => {
	  	  promises.push(
		    addDoc(collection(db, "notifications"), {
			  userId: userDoc.id,
			  title: `üöÄ Mise √† jour du site (${version})`,
			  message: message,
			  read: false,
			  createdAt: serverTimestamp()
		    })
		  );
	    });

	    await Promise.all(promises);

	    await setDoc(metaRef, {
		  version,
		  createdAt: serverTimestamp()
	    });

	    console.log("‚úÖ Notification de mise √† jour envoy√©e");
	    */
	  }
	  async function notifyNewAnimeOnce(animeId, animeTitle) {
	    console.warn("notifyNewAnimeOnce est d√©sactiv√© c√¥t√© client. √Ä d√©placer c√¥t√© backend (Cloud Function).", { animeId, animeTitle });
	    return;

	    /*
	    const metaRef = doc(db, "meta", `anime_${animeId}`);
	    const snap = await getDoc(metaRef);

	    // ‚õî D√©j√† notifi√© ‚Üí on stop
	    if (snap.exists()) return;

	    const usersSnap = await getDocs(collection(db, "users"));

	    const promises = [];
	    usersSnap.forEach(userDoc => {
		  promises.push(
		    addDoc(collection(db, "notifications"), {
			  userId: userDoc.id,
			  title: "üÜï Nouvel anime ajout√©",
			  message: animeTitle,
			  read: false,
			  createdAt: serverTimestamp()
		    })
	  	  );
	    });

	    await Promise.all(promises);

	    // üîí Marque cet anime comme "d√©j√† notifi√©"
	    await setDoc(metaRef, {
		  animeId,
		  animeTitle,
		  createdAt: serverTimestamp()
	    });

	    console.log(`‚úÖ Notification envoy√©e pour l'anime : ${animeTitle}`);
        */
	  }
	  async function loadAnimes() {
	    const animesCol = collection(db, "animes");
	    const snapshot = await getDocs(animesCol);

	    const animes = snapshot.docs.map(docSnap => {
		  const data = docSnap.data();
		  const anilistScore = Number.isFinite(data.anilistScore)
			? data.anilistScore / 10
			: null;
		  const rating = Number.isFinite(data.avgRating)
			? data.avgRating
			: anilistScore;
		  return {
		    id: Number(docSnap.id),
		    title: data.title,
		    genre: data.genre || [],
		    img: data.img || "icon_animehub.png",
		    rating,
		    likes: data.likes || 0,
		    year: data.seasonYear || data.year || null,
		    summary: data.summary || "",
		    timeline: data.timeline || [],
		    fav: false
		  };
	    });
		
		if (typeof ANIMES !== "undefined") {
		  ANIMES.splice(0, ANIMES.length, ...animes);
		  window.AnimeHub = { ANIMES, renderList, applyFilters };
		  refreshGenres();
		}
		
	    const grid = document.getElementById('grid');
	    const loading = document.getElementById('loading');

	    loading.style.display = "none";
	    grid.style.display = "grid";
		if (pageLoader) {
		  pageLoader.style.display = "none";
		  pageLoader.setAttribute("aria-busy", "false");
		}
	  }
	  // notifications ponctuelles g√©r√©es c√¥t√© backend si besoin
  </script>
</body>
</html>
